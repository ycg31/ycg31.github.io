{"meta":{"title":"杂记","subtitle":"记录网上生活","description":"有了这个，就不用到处去找重复的了","author":"ycg31","url":"https://ycg31.oschina.io"},"pages":[{"title":"Tags","date":"2017-08-20T16:25:32.477Z","updated":"2017-08-20T16:25:32.477Z","comments":true,"path":"tags/index.html","permalink":"https://ycg31.oschina.io/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2017-08-22T14:24:28.016Z","updated":"2017-08-20T16:25:32.461Z","comments":true,"path":"about/index.html","permalink":"https://ycg31.oschina.io/about/index.html","excerpt":"","text":""},{"title":"Project","date":"2017-08-20T16:26:13.910Z","updated":"2017-08-20T16:25:32.461Z","comments":true,"path":"project/index.html","permalink":"https://ycg31.oschina.io/project/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-08-19T20:00:21.000Z","updated":"2017-08-22T14:25:10.443Z","comments":true,"path":"categories/index.html","permalink":"https://ycg31.oschina.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Git忽略规则和.gitignore规则不生效的解决办法","slug":"Git忽略规则和-gitignore规则不生效的解决办法","date":"2017-08-20T15:42:24.000Z","updated":"2017-08-20T15:58:32.151Z","comments":true,"path":"2017/08/20/Git忽略规则和-gitignore规则不生效的解决办法/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/Git忽略规则和-gitignore规则不生效的解决办法/","excerpt":"","text":"Git忽略规则：在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如果没有这个文件，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则例如： 以斜杠“/”开头表示目录； 以星号“*”通配多个字符； 以问号“?”通配单个字符 以方括号“[]”包含单个字符的匹配列表； 以叹号“!”表示不忽略(跟踪)匹配到的文件或目录； 12345678910# 此为注释 – 将被 Git 忽略*.sample # 忽略所有 .sample 结尾的文件!lib.sample # 但 lib.sample 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txtfd1/* #忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；/fd1/* #忽略根目录下的 /fd1/ 目录的全部内容；#此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效； 实现的三种方法有三种方法可以实现过滤掉Git里不想上传的文件，这三种方法都能达到目的，只不过适用情景不一样。 第一种方法针对单一工程排除文件，这种方式会让这个工程的所有修改者在克隆代码的同时，也能克隆到过滤规则，而不用自己再写一份，这就能保证所有修改者应用的都是同一份规则，而不是张三自己有一套过滤规则，李四又使用另一套过滤规则，个人比较喜欢这个。配置步骤如下： 在工程根目录下建立.gitignore文件，将要排除的文件或目录 写到.gitignore这个文件中，其中有两种写入方法。 a)使用命令行增加排除文件排除以.class结尾的文件 echo “*.class” &gt;.gitignore (&gt;&gt; 是在文件尾增加,&gt; 是删除已经存在的内容再增加)，之后会在当前目录下生成一个.gitignore的文件。排除bin目录下的文件 echo “bin/” &gt;.gitignore b)最方便的办法是，用记事本打开，增加需要排除的文件或目录，一行增加一个。第二种方法全局设置排除文件，这会在全局起作用，只要是Git管理的工程，在提交时都会自动排除不在控制范围内的文件或目录。这种方法对开发者来说，比较省事，只要一次全局配置，不用每次建立工程都要配置一遍过滤规则。但是这不保证其他的开发者在克隆你的代码后，他们那边的规则跟你的是一样的，这就带来了代码提交过程中的各种冲突问题。配置步骤如下： a）像方法（1）一样，也需要建立一个.gitignore文件，把要排除的文件写进去。b）但在这里，我们不规定一定要把.gitnore文件放到某个工程下面，而是任何地方，比如我们这里放到了Git默认的Home路径下，比如：/home/wangshibo/hqsb_iosc）使用命令方式可以配置全局排除文件 git config –global core.excludesfile ~/.gitignore，你会发现在~/.gitconfig文件中会出现excludesfile = /home/wangshibo/hqsb_ios/.gitignore。说明Git把文件过滤规则应用到了Global的规则中。 第三种方法单个工程设置排除文件，在工程目录下找到.git/info/exclude，把要排除的文件写进去： 这种方法就不提倡了，只能针对单一工程配置，而且还不能将过滤规则同步到其他开发者，跟方法（1）（2）比较起来没有一点优势。 .gitignore规则不生效的解决办法把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被追踪的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未被追踪状态），然后再提交： 123git rm -r --cached .git add .git commit -m 'update .gitignore' 注意：不要误解了 .gitignore 文件的用途，该文件只能作用于 Untracked Files，也就是那些从来没有被 Git 记录过的文件（自添加以后，从未 add 及 commit 过的文件）。如果文件曾经被 Git 记录过，那么.gitignore 就对它们完全无效。","categories":[{"name":"网络技术","slug":"网络技术","permalink":"https://ycg31.oschina.io/categories/网络技术/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ycg31.oschina.io/tags/git/"}]},{"title":"如何免费打造打造一个安全稳定低延迟超高速的科学上网环境","slug":"如何免费打造打造一个安全稳定低延迟超高速的科学上网环境","date":"2017-08-20T09:07:09.000Z","updated":"2017-08-20T09:07:57.916Z","comments":true,"path":"2017/08/20/如何免费打造打造一个安全稳定低延迟超高速的科学上网环境/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/如何免费打造打造一个安全稳定低延迟超高速的科学上网环境/","excerpt":"","text":"如何免费打造打造一个安全稳定低延迟超高速的科学上网环境这篇文章将会介绍如何获取由 Google 提供的一年 $300 美金的试用金，然后使用 HyperApp 搭建一个低延迟超高速的科学上网环境。网络延迟基本在50ms左右，并且可以流畅观看 Youtube 4K 视频。本文不需要读者有较深的技术背景，全部过程都可视化、自动化完成。 下文用 GCP 代表 Google Cloud Platform，指 Google 的整个云平台。GCE 是指 Google Cloud Engine，是 GCP 产品线里的一个主机产品。 本文前提条件 有一个 Google 账号，没有的话可以注册一个。 注册 GCP 免费试用需要用信用卡进行身份验证（只做验证，不会收费），所以你必须有一个 Visa/MasterCard 的信用卡才行。 本文目录 GCP 注册以及创建服务器 注册 GCP 新建主机 HyperApp 添加服务器到 HyperApp 配置公钥 开启 BBR 加速，跑满带宽 部署科学上网应用 客户端设置 常见问题 GCP 注册以及创建服务器要访问 Google 首先需要你能科学上网，但是这篇文章又是介绍如何科学上网的，好像有点🐔生蛋蛋生🐔的矛盾… 其实你可以去App Store搜索 V屁恩，找一个免费的下载后，通过签到等方式暂时领取一天或者几个小时的免费低速试用来完成下面的教程。 注册 GCP 免费试用 登录Google账号后使用这个链接来注册 https://cloud.google.com/free/ ，在打开的页面中点击“Try it Free”。 接受条款，并点击”同意并继续“ 在页面中填入你的信息： 账号类型：个人 名称和地址：填写你的地址、电话等 付款方式：添加一个信用卡。这个信用卡将会用来验证身份，防止GCP被滥用。 点击 ”开始免费使用“ 完成注册 在后面的页面中，如果你能看到页面顶部有一个“礼物 🎁 ” 的小图标，说明已经获取了试用金。 新建主机 按照上图所示，在左侧菜单中导航到 计算引擎 → VM 实例 点击加号按钮，创建一个 VM 实例。 名称：随意填入一个易记得名字 地区：建议选择 asia-east1-* 三个中的任意一个，这个机房是在台湾，国内的延迟只有 50~70ms，简直快到飞起。 机器类型：选择 “小型” (1.7G 内存) 就可以了。默认选中的 3.75G 的内存其实用不完。（只用SS的话建议选最低配置的，这样每月大约可以留出来80G流量） 启动磁盘：默认的Debian 8就可以，推荐 Ubuntu 16.04 或者 CentOs 7，但是为了防止将来磁盘不够用，你可以点击右下角的更改，大小里使用 20G 或者 30G。 防火墙：选中 “允许HTTP流量” 和 “允许HTTPS流量” 注意：GCE 的 CentOS 有各种小问题，如果你执意要用 CentOS 遇到问题请自行 Google 点击”创建“，稍等几分钟就会创建完毕，现在打开 HyperApp 开始配置这台服务器吧。 HyperAppHyperApp 是一个部署自动化以及服务器监控管理的App，致力于让普通用户也可以使用云服务。HyperApp 可以监控服务器/路由器的运行状态，还可以可视化的一键部署各种应用。 本段介绍如何使用 HyperApp 管理刚刚创建的服务器，开启 BBR 加速，安装科学上网应用。 添加服务器到 HyperApp 在 “服务器” 页面点击右下角的加号，然后选择第二个”自动配置“ 点击“开始”，应用会自动生成一对密钥，请耐心等到几秒~十几秒。 等到出现“一切就绪”时，点击“复制“将代码复制到剪贴板里，如果你用电脑操作的话可以点击”发送“将代码通过任意一种方式发送到电脑上。 在 GCE 计算引擎 → VM 实例 页面，选择刚刚创建的实例的 SSH ▽ 在浏览器窗口中打开 打开一个基于 Web 的 SSH 终端。 在浏览器的SSH中粘贴并运行刚刚复制的代码。等到二维码出现时，使用 HyperApp 扫描该二维码便会自动添加该服务器。添加后 HyperApp 会检测刚刚添加的服务器的基本运行状况。 永久添加公钥注意：你可以暂时跳过本小段，进行后续的操作，如果 HyperApp 出现了密钥认证错误的提示，可以回到这段进行操作。 刚刚的自动配置的功能在几乎所有主机上都可以用，但是 GCE 是个例外，它会清空用户自行添加的公钥，所以几分钟后可能就会出现密钥认证失败的错误。你可以通过以下步骤永久性的设置密钥。 打开 HyperApp → 更多 → SSH Keys → 点击唯一的一个 Key → 复制公钥。 打开 GCP → 计算引擎 → 元数据 → SSH 密钥 点击修改后，复制并添加刚刚的公钥。 添加后页面会出现一行新记录，主要有两列：用户名 和 密钥。然后确保 HyperApp → 服务器 → 点击服务器下面的齿轮按钮 用户名为这儿显示的用户名，保存后就可以了。（如果你按照上面的步骤操作，HyperApp 自动修改用户名所以这两个用户名应该默认是一致的） 添加以后同一账号下所有新建的主机都可以不用再次操作了。 开启 BBR 加速，跑满带宽这一步并不影响科学上网，但是会极大的提高上网质量。BBR是 Google 开发的TCP拥塞控制技术，并且已经合并到较新的Linux内核中。它的主要作用是可以让你跑满服务器的带宽。 比如说没有开启的情况下你观看 Youtube 720P的视频都可能会卡，但是开启了BBR后 1080P 的视频完全无卡顿，就连 4K 视频也可以流畅观看（有些网络特别卡的除外）。 要开启 BBR 需要升级 Linux 内核，不过不用急，在 HyperApp 中开启非常简单： 在服务器卡片中点击右上角的 Terminal 图标，进入 SSH 终端。 选择最下面的一行工具栏的第一个图标，然后点击 “teddyun/BBR” 一键脚本的链接，点击后会让你确认是否下载并执行外部脚本。 点击确认后会自动下载并执行，执行过程中需要点击键盘上回车键确认继续。如果想中断执行，那么点击 ctrl 后按 c终止执行。 稍等几分钟，等待系统内核升级到最新版后会自动重启（重启时终端会显示Done 和 Shell Closed）然后关闭窗口即可。 如果你想确认 BBR 有没有安装成功，那么再次进入 SSH 终端，输入 lsmod | grep bbr 如果能看到一行记录就是成功了。 注意：一定要先升级BBR再安装应用，反过来会出错，如果你不小心操作错了顺序，请参考 排错指引。 部署科学上网应用 在 HyperApp → 商店 页面 网络 分组下选择任意一个应用，这里我们选择占用资源最少的 ****-libev，（下文用SS代替）点击该应用。在弹出的对话框中选择刚刚添加的服务器，点击创建应用 在此页面中输入简单的一些配置： Port: 端口，可以填入 80 或者 443（因为用其它端口需要设置防火墙） Password：随便填入一个密码 Encrypt：选择一种加密方式，推荐针对移动访问优化的 chacha20 OBFS: 使用 OBFS 可以将 SS 流量伪装成正常的网页访问从而达到欺骗效果，可以防止被墙或者运营商干扰。 如果你使用其它端口，请参考文末的 设置GCE防火墙 如何开启防火墙。 如果安装的过程中出现错误，可以截图后进群寻求帮助，但最快的方式依然是：建一个新的vm重来一遍！真的，很神奇的！ 客户端设置iOSiOS 上有很多 SS 的客户端可供选择，收费的有 小火箭、土豆丝、Surge等。免费的可以使用 Wingy。 配置很简单，只需要点击应用卡片里的服务器栏，然后选择顶部的QR，截图后用其它客户端扫码即可。 如果你想手动配置，请按指示填写参数即可，下面和配置和上面 【部署科学上网应用】段落里第2步的配置一一对应： 服务器：填入你的服务器外部 IP（GCP后台 VM列表页面有一列外部IP，就是那个）。 端口：上面配置界面里面的端口（80，或者443） 密码：上面配置界面里面的密码 加密方式：上面配置界面里面的加密方式 Mac/WindowsMac 和 Windows 上都有免费的 SS 客户端可以使用，配置方法也是只要输入你的IP、端口、密码和加密方式即可。 常见问题：如何建多个账号？你可以创建多个应用给不同的人使用，一个应用只占 1~2M 内存（但注意每个应用的端口必须不同） 信用卡被扣一美元？这是验证信用卡信息是否正确的，快则几分钟慢则几小时就会退款。 结算账号被关闭怎么办？你可能没仔细填信用卡信息，查看你的邮箱应该会有一封谷歌的通知邮件，按照提示传下资料，几个小时左右就会被解封了。 其它玩法现在你有了一台 1.75G 内存的服务器了，只用来做SS好像有点浪费（SS只占用几M内存），其实使用 HyperApp 还有很多其它玩法，商店里面有很多其它应用，都可以自动安装配置。 比如你可以自己搭建一个博客、网站、论坛，个人网盘，聊天服务，并且可以自动配置HTTPS。如果你玩游戏可以创建一个 Minecraft 服务器。或者部署一个接收微信消息转发到Telegram的机器人。更多信息可以参阅👇 的 HyperApp 文档和教程。 HyperApp 支持官方文档和教程Telegram 群 Twitter @HyperApp 如果你遇到了各种各样的技术问题，比如无法安装、无法连接等，可以在群里召唤机器人或者开发者进行解答。或者在App里面点击 发送反馈邮件 获取帮助，这两种是最快的获取帮助的方式。 设置 GCE 防火墙 在GCP后台点击 网络 → 防火墙规则 点击 1创建防火墙规则 名称：随便输入一个名称 目标：选择 网络中的所有示例 来源过滤：0.0.0.0/0 协议和端口：指定的协议和端口 下面输入 tcp;udp:端口号 自建和购买商业服务对比有什么优势？ 最主要的优势是隐私和安全，如果你看下上面SS的日志，你就知道服务商可以知道你的所有浏览历史的，如果你访问了不支持HTTPS的网站，那么请求内容也可能被监控（比如密码信息）。 另外是质量和成本，很多商家是使用和上面同样的机器但是卖给几百个人，你应该能明白了。成本方面没有免费试用的话1个人用可能会有点贵，但如果和朋友家人一起用就超值了，比如使用$2.5/月的 Vultr，每月500G 流量够很多人用的。","categories":[{"name":"代理技术","slug":"代理技术","permalink":"https://ycg31.oschina.io/categories/代理技术/"}],"tags":[{"name":"GCP","slug":"GCP","permalink":"https://ycg31.oschina.io/tags/GCP/"}]},{"title":"Git远程操作详解","slug":"Git远程操作详解","date":"2017-08-19T23:22:09.000Z","updated":"2017-08-20T05:48:19.466Z","comments":true,"path":"2017/08/20/Git远程操作详解/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/Git远程操作详解/","excerpt":"","text":"Git是目前最流行的版本管理系统，学会Git几乎成了开发者的必备技能。 Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。 git clone git remote git fetch git pull git push 本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。 一、git clone远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。 123&gt; $ git clone &lt;版本库的网址&gt;&gt;&gt; 比如，克隆jQuery的版本库。 123&gt; $ git clone https://github.com/jquery/jquery.git&gt;&gt; 该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。 123&gt; $ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;&gt;&gt; git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。 123456789&gt; $ git clone http[s]://example.com/path/to/repo.git/&gt; $ git clone ssh://example.com/path/to/repo.git/&gt; $ git clone git://example.com/path/to/repo.git/&gt; $ git clone /opt/git/project.git &gt; $ git clone file:///opt/git/project.git&gt; $ git clone ftp[s]://example.com/path/to/repo.git/&gt; $ git clone rsync://example.com/path/to/repo.git/&gt;&gt; SSH协议还有另一种写法。 123&gt; $ git clone [user@]example.com:path/to/repo.git/&gt;&gt; 通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。 二、git remote为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。 不带选项的时候，git remote命令列出所有远程主机。 1234&gt; $ git remote&gt; origin&gt;&gt; 使用-v选项，可以参看远程主机的网址。 12345&gt; $ git remote -v&gt; origin git@github.com:jquery/jquery.git (fetch)&gt; origin git@github.com:jquery/jquery.git (push)&gt;&gt; 上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。 克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。 12345&gt; $ git clone -o jQuery https://github.com/jquery/jquery.git&gt; $ git remote&gt; jQuery&gt;&gt; 上面命令表示，克隆的时候，指定远程主机叫做jQuery。 git remote show命令加上主机名，可以查看该主机的详细信息。 123&gt; $ git remote show &lt;主机名&gt;&gt;&gt; git remote add命令用于添加远程主机。 123&gt; $ git remote add &lt;主机名&gt; &lt;网址&gt;&gt;&gt; git remote rm命令用于删除远程主机。 123&gt; $ git remote rm &lt;主机名&gt;&gt;&gt; git remote rename命令用于远程主机的改名。 123&gt; $ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;&gt;&gt; 三、git fetch一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。 123&gt; $ git fetch &lt;远程主机名&gt;&gt;&gt; 上面命令将某个远程主机的更新，全部取回本地。 git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。 默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。 123&gt; $ git fetch &lt;远程主机名&gt; &lt;分支名&gt;&gt;&gt; 比如，取回origin主机的master分支。 123&gt; $ git fetch origin master&gt;&gt; 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。 git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。 12345678&gt; $ git branch -r&gt; origin/master&gt;&gt; $ git branch -a&gt; * master&gt; remotes/origin/master&gt;&gt; 上面命令表示，本地主机的当前分支是master，远程分支是origin/master。 取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。 123&gt; $ git checkout -b newBrach origin/master&gt;&gt; 上面命令表示，在origin/master的基础上，创建一个新分支。 此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。 12345&gt; $ git merge origin/master&gt; # 或者&gt; $ git rebase origin/master&gt;&gt; 上面命令表示在当前分支上，合并origin/master。 四、git pullgit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。 123&gt; $ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;&gt;&gt; 比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。 123&gt; $ git pull origin next:master&gt;&gt; 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。 123&gt; $ git pull origin next&gt;&gt; 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。 1234&gt; $ git fetch origin&gt; $ git merge origin/next&gt;&gt; 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。 Git也允许手动建立追踪关系。 123&gt; git branch --set-upstream master origin/next&gt;&gt; 上面命令指定master分支追踪origin/next分支。 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。 123&gt; $ git pull origin&gt;&gt; 上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。 如果当前分支只有一个追踪分支，连远程主机名都可以省略。 123&gt; $ git pull&gt;&gt; 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。 如果合并需要采用rebase模式，可以使用--rebase选项。 123&gt; $ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;&gt;&gt; 如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。 但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。 123456&gt; $ git pull -p&gt; # 等同于下面的命令&gt; $ git fetch --prune origin &gt; $ git fetch -p&gt;&gt; 五、git pushgit push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。 123&gt; $ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;&gt;&gt; 注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。 如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 123&gt; $ git push origin master&gt;&gt; 上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。 12345&gt; $ git push origin :master&gt; # 等同于&gt; $ git push origin --delete master&gt;&gt; 上面命令表示删除origin主机的master分支。 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 123&gt; $ git push origin&gt;&gt; 上面命令表示，将当前分支推送到origin主机的对应分支。 如果当前分支只有一个追踪分支，那么主机名都可以省略。 123&gt; $ git push&gt;&gt; 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。 123&gt; $ git push -u origin master&gt;&gt; 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。 不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。 12345&gt; $ git config --global push.default matching&gt; # 或者&gt; $ git config --global push.default simple&gt;&gt; 还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用--all选项。 123&gt; $ git push --all origin&gt;&gt; 上面命令表示，将所有本地分支都推送到origin主机。 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。 123&gt; $ git push --force origin &gt;&gt; 上面命令使用--force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用--force选项。 最后，git push不会推送标签（tag），除非使用--tags选项。 123&gt; $ git push origin --tags&gt;&gt; （完）","categories":[{"name":"网络技术","slug":"网络技术","permalink":"https://ycg31.oschina.io/categories/网络技术/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ycg31.oschina.io/tags/git/"}]},{"title":"git pull 和 clone的区别及用法","slug":"git pull和clone的区别及用法","date":"2017-08-19T21:22:09.000Z","updated":"2017-08-20T05:47:49.850Z","comments":true,"path":"2017/08/20/git pull和clone的区别及用法/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/git pull和clone的区别及用法/","excerpt":"","text":"一、git pullgit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。 完整格式：$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 完整格式举例：比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样， （1）$ git pull origin next:master：如果远程分支是与当前分支合并，则冒号后面的部分可以省略。（2）$ git pull origin next：上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。12$ git fetch origin$ git merge origin/next 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。 Git也允许手动建立追踪关系，git branch –set-upstream master origin/next上面命令指定master分支追踪origin/next分支。如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。 1$ git pull origin 上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”(remote-tracking branch)进行合并。如果当前分支只有一个追踪分支，连远程主机名都可以省略。 二、get clone远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。 ##（1）$ git clone &lt;版本库的网址&gt;比如，克隆jQuery的版本库。1$ git clone https://github.com/jquery/jquery.git 该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。 （2）$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。1234567$ git clone http[s]://example.com/path/to/repo.git/$ git clone ssh://example.com/path/to/repo.git/$ git clone git://example.com/path/to/repo.git/$ git clone /opt/git/project.git$ git clone file:///opt/git/project.git$ git clone ftp[s]://example.com/path/to/repo.git/$ git clone rsync://example.com/path/to/repo.git/ （3）SSH协议还有另一种写法。1$ git clone [user@]example.com:path/to/repo.git/ 通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。","categories":[{"name":"网络技术","slug":"网络技术","permalink":"https://ycg31.oschina.io/categories/网络技术/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ycg31.oschina.io/tags/git/"}]},{"title":"远程GitHub中的灰色图标的解决办法","slug":"远程GitHub中的灰色图标的解决办法","date":"2017-08-19T21:22:09.000Z","updated":"2017-08-20T05:48:02.687Z","comments":true,"path":"2017/08/20/远程GitHub中的灰色图标的解决办法/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/远程GitHub中的灰色图标的解决办法/","excerpt":"","text":"问题描述任何人都可以告诉我为什么我把我的文件推送到github时有灰色图标？在应用程序目录中，应该有模型，视图和控制器，但在远程GitHub中，我无法点击。 最佳解决方案看起来你创建了一个子模块，指向一个不可达的远程位置。 见this answer。该图标在绿色时将指向子模块。因为子模块配置不正确，我认为你的情况是灰色的。 鉴于.gitmodules不存在，它必须被删除，留下没有远程信息的子模块。 如果进入app并键入git remote -v，您将看到该模块指向的位置。这个地方目前无法到达。 在类似的情况下，我添加了一个子模块并删除了.gitmodules。 GitHub的结果如下所示： 次佳解决方案看起来你在文件夹中初始化了git。从子文件夹中删除git文件(rm -rf)，并创建一个新的repo并重新初始化git。 第三种解决方案1git rm --cached &lt;folder_name&gt; 然后转到父目录，然后执行： 123git add .git commit -m \"&lt;your_message&gt;\"git push --all","categories":[{"name":"网络技术","slug":"网络技术","permalink":"https://ycg31.oschina.io/categories/网络技术/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ycg31.oschina.io/tags/git/"}]},{"title":"使用AppVeyor自动部署Hexo到Github","slug":"使用AppVeyor自动部署Hexo到Github","date":"2017-08-19T20:22:09.000Z","updated":"2017-08-20T05:47:31.909Z","comments":true,"path":"2017/08/20/使用AppVeyor自动部署Hexo到Github/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/使用AppVeyor自动部署Hexo到Github/","excerpt":"","text":"一、转载别人的教程想必很多人会把Hexo生成出来的静态网站放到GitHub Pages来进行托管。一般发布Hexo博客的流程是，首先在本地搭建Hexo的环境，编写新文章，然后利用hexo deploy来发布到Git。那么对于本地的Hexo的原始文件怎么管理呢？如果换电脑了怎么办？如果没有对原始文件进行备份，突然有一天你的本地环境挂了导致源文件丢失，那不就呵呵了。也许你会想到用Dropbox或者其他方案来对源文件进行备份，但是每次更新完博客，需要备份好源文件，然后执行hexo deploy进行发布，是不是很麻烦？换了电脑之后又要重新搭建本地环境，是不是很蛋疼？ 那么接下来我们就来说说如何优雅愉快地对我们的Hexo进行版本管理和发布。 ​ 既然我们已经用了GitHub来托管我们生成出来的静态网站，那么为什么不也把Hexo博客的源文件也host在GitHub上呢。那么问题来了，如果我们把Hexo博客的源文件托管在GitHub上，我们的发布流程就会变为： 执行git push把更新的源文件push到托管源文件的GitHub Repo (我们称之为Source Repo) 执行hexo deploy来更新托管静态网站的GitHub Pages (我们称之为Content Repo) ​ 这样看来，每次更新博客要经历两个步骤，并不是那么straightforward。那么有没有办法做到既能使用GitHub进行版本控制，又能做到一键发布呢？ ​ 答案是肯定的。这里用到了持续集成也就是我们一直所说的CI来完成一键发布：当有新的change push到Source Repo时，自动执行CI脚本，生成最新的静态网站发布到Content Repo，一气呵成。那么我使用什么CI工具来做呢？我们可以使用像Travis CI这样的Hosted CI Service，也可以使用Jenkins或者TeamCity来搭建CI server。如果自己来搭建CI Server，费时费力，又要花钱来买Server来host CI service，肯定不是一个很好的选择。那么我们选哪个Hosted CI Service呢？其实今年在公司的一个项目中我们就选择了AppVeyor。当初在做investigation的时候，第一个想到的就是用Travis CI，然而我司大多数的开发环境都是Windows，而且当时的项目有Python, PowerShell, Java等，那时PowerShell还只支持Windows，所以需要选择一个支持Windows的CI Service。于是，Scott Hanselman安利的AppVeyor就成为了一个备选。访问AppVeyor官网，映入眼帘的大标题就是#1 Continuous Delivery service for Windows。刚开始的时候内心一阵嘲笑，Top 10的CI Service就你支持Windows，你不是第一那谁是第一？结果在之后的项目使用中，发现AppVeyor比Travis CI好用太多。这里就不具体展开了，继续进入正题。 ​ 使用AppVeyor来建立CI非常方便，主要是以下步骤： 1. 注册并登陆AppVeyor 访问AppVeyor登陆页面，使用你的GitHub账号登陆即可。 ​ 2. 添加Project 在AppVeyor Projects页面，添加相应的GitHub Source Repo。 ​ ## 3. 添加appveyor.yml到Source Repo 接下来，你需要把appveyor.yml添加到Source Repo的根目录下。具体的appveyor.yml如下: 1234567891011121314151617181920212223242526272829clone_depth: 5environment:access_token: secure: [Your GitHub Access Token]install:- node --version- npm --version- npm install- npm install hexo-cli -gbuild_script:- hexo generateartifacts:- path: public on_success:- git config --global credential.helper store- ps: Add-Content \"$env:USERPROFILE\\.git-credentials\" \"https://$($env:access_token):x-oauth-basic@github.com`n\"- git config --global user.email \"%GIT_USER_EMAIL%\"- git config --global user.name \"%GIT_USER_NAME%\"- git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site- cd %TEMP%\\static-site- del * /f /q- for /d %%p IN (*) do rmdir \"%%p\" /s /q- SETLOCAL EnableDelayedExpansion &amp; robocopy \"%APPVEYOR_BUILD_FOLDER%\\public\" \"%TEMP%\\static-site\" /e &amp; IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1))- git add -A- git commit -m \"Update Static Site\" - git push origin %TARGET_BRANCH%- appveyor AddMessage \"Static Site Updated\" 你唯一需要做的就是替换[Your GitHub Access Token]，关于生成Access Token，可以参考这篇文章。在GitHub生成好Access Token之后，你需要到AppVeyor加密页面把Access Token加密之后再替换[Your GitHub Access Token] ​ 4. 设置Appveyor 添加好appveyor.yml之后，再到Appveyor portal设置以下四个变量。STATIC_SITE_REPO就是Content Repo的地址，TARGET_BRANCH就是你Content Repo的branch，一般默认就是master，GIT_USER_EMAIL和GIT_USER_NAME就是你GitHub账号的信息。 ​ 好了，一切大功告成！试一下git push你的change到Source Repo，几分钟内，你的博客就自动更新了！ 背后的过程如下: Git push to Source Repo –&gt; AppVeyor CI –&gt; Update GitHub Pages Content Repo –&gt; Generate your Hexo blog site 折腾过程中遇到的问题部署成功后，所有创建的html文件全部是空的，几经周折才发现，原来是缺少主题文件，所有生成的html文件全是空的，提示错误WARN No layout，再到GitHub上一看，主题文件夹变成了灰色。具体如何解决灰色文件夹可以参考我转载的另一篇文章。","categories":[{"name":"网络技术","slug":"网络技术","permalink":"https://ycg31.oschina.io/categories/网络技术/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ycg31.oschina.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://ycg31.oschina.io/tags/hexo/"},{"name":"appveyor","slug":"appveyor","permalink":"https://ycg31.oschina.io/tags/appveyor/"}]},{"title":"使用Travis CI自动部署Hexo","slug":"使用Travis-CI自动部署Hexo","date":"2017-08-19T19:41:09.000Z","updated":"2017-08-20T06:45:39.365Z","comments":true,"path":"2017/08/20/使用Travis-CI自动部署Hexo/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/使用Travis-CI自动部署Hexo/","excerpt":"","text":"前两天了解到了一个有趣的概念叫持续集成： 持续集成是一种软件开发实践。在持续集成中，团队成员频繁集成他们的工作成果，一般每人每天至少集成一次，也可以多次。每次集成会经过自动构建（包括自动测试）的检验，以尽快发现集成错误。许多团队发现这种方法可以显著减少集成引起的问题，并可以加快团队合作软件开发的速度。这篇文章简要介绍了持续集成的技巧和它最新的应用。 然后想到我的博客也恰好满足这样的需求，因为我的博客一旦有了修改，就必须要重新build并且部署，那么能不能用持续集成的思想来改造我部署博客的流程呢？ 在这样的指导思想下，我完成了上一篇文章：VPS搭配Github Webhook实现Hexo自动发布，而今天我要介绍一下，在没有VPS的情况下，如何更方便的配置自己的持续集成的博客。 好处 方便：只需要一次配置，便省去了每一次编辑文档后，都需要进行hexo d -g的麻烦，更不必说文章增多之后渲染时间还会增长。 稳定：这个是最近才发现的，Github被搞了之后，很多人反映不能更新博客了，使用Travis CI，你只要想办法提交一个小md文档，就能进行构建。如果自己手动构建，只要一个文件上传失败，前面的工作都白费了。 快捷：即使是出差在外，只要能编辑Markdown，就可以撰写博客，使得Hexo拥有类似于WP一致的体验~ 协作：博客的构建完全交由Travis CI进行，所以完全可以通过Hexo+git构建一个多人协作的博客平台。实际上，Hexo的官网正是这样构建的。 Travis CI介绍 Travis CI是在软件开发领域中的一个在线的，分布式的持续集成服务，用来构建及测试在GitHub托管的代码。这个软件的代码同时也是开源的，可以在GitHub上下载到，尽管开发者当前并不推荐在闭源项目中单独使用它。 它提供了多种编程语言的支持，包括Ruby，JavaScript，Java，Scala，PHP，Haskell和Erlang在内的多种语言。许多知名的开源项目使用它来在每次提交的时候进行构建测试，比如Ruby on Rails，Ruby和Node.js。 2012年，Travis CI 决定进行募资以支持后续的开发，在这次募资活动中，许多重量级的科技公司给予了资助。 需要注意的是几个特性： 只支持Github 支持JavaScript 开源，免费 然后介绍一下它的原理： Travis CI会在你每一次提交之后生成一个虚拟机来执行你事先安排好的build任务，你可以调整这个虚拟机的软件环境，甚至能执行sudo来进行apt-get install。 Travis CI配置我们知道，Hexo的命令非常简单，一个hexo d -g就可以搞定。困难之处在于，Travis CI并没有对你的库进行push操作的权限。如果直接将私钥放在自己的开源库之中，这无异于将自己的代码库提交权限开放给了所有的Github使用者。所以，为了保护自己，我们需要采取一些配置操作。 感谢Hexo作者tommy351提供的操作流程，原文可见于用 Travis CI 自動部署網站到 GitHub Travis CI使用SSH 连接GitHub生成SSH Key参见使用Github SSH Key以免去Hexo部署时输入密码 需要注意的是，这个SSH key不应成为你账号的全局SSH key（因为这样Travis CI就获得了你所有代码库的提交权限，这是不正确的），而应该添加至https://github.com/username/ropename/settings/keys ，这样，你就控制了Travis CI的权限。 ###加密私钥 下面的操作需要事先配置好gem环境，如果没有可以尝试使用强大且配置项丰富的在线IDE应用——Cloud9。 安装Travis CI的命令行工具1gem install travis # 安装travis 登陆Travis CI需要输入Github账号和密码 1travis login --auto 加密私钥并上传至Travis正确生成后你会得到两个文件，一个叫ssh_key，一个叫ssh_key.pub。刚才我们将ssh_key.pub添加到了github，下面我们要加密ssh_key这个私钥并且上传到Travis。 1travis encrypt-file ssh_key --add 然后Travis的客户端会自动检测当前目录中的git信息，并且添加到.travis.yml中去。在进行此步操作前，目录下要先存在.travis.yml文件，否则会报错。 指定SSH设置在当前目录下新建文件ssh_config，内容为 12345Host github.com User git StrictHostKeyChecking no IdentityFile ~/.ssh/id_rsa IdentitiesOnly yes 然后指定openssl解密后的生成位置，修改Travis自动插入的解密指令(不要照抄，注意修改密钥) 12- openssl aes-256-cbc -K $encrypted_xxxxxxxxxx_key -iv $encrypted_xxxxxxxxxx_iv -in travis.enc -out ~/.ssh/id_rsa -d 修改目录权限紧跟那条解密指令，换行输入： 1- chmod 600 ~/.ssh/id_rsa 注意yml格式，短杠后面的空格不能省略。 将密钥加入系统紧跟上一步操作，换行输入： 12- eval $(ssh-agent)- ssh-add ~/.ssh/id_rsa 修改git信息将之前创建的ssh_config复制到Travis的虚拟机中去，输入： 1- cp ssh_config ~/.ssh/config 然后指定git使用者信息： 12- git config --global user.name \"username\"- git config --global user.email username@example.com Build配置之前的所有操作都只是为了让Travis CI拥有push权限，下面我们开始进入到真正的Build配置当中。 之前我们用到了一个名为.travis.yml的文件，跟build有关的所有设置都在这个文件里面，下面的操作都在这个文件当中进行。 指定环境在文件中添加如下代码： 1234language: node_jsnode_js:- '0.10' //指定使用node.js最新的稳定版0.10 指定分支在文件中添加如下代码： 123branches: only: - blog //这个分支应当使用自己的源文件分支 差点忘了讲- -，本方案只适用于用github来托管自己自己的hexo目录的用户。这里的分支应该使用包含有.md文档的那个分支。 Hexo配置首先在虚拟机中安装Hexo： 1234install:- npm install hexo-cli -g- npm install hexo --save- npm install 然后执行Hexo的渲染操作 1234script:- hexo clean //分开写，方便调试可能出现的错误- hexo d- hexo g 到这里，你的Travis CI的持续集成已经配置完毕了，最后的.travis.yml文件内容可以参考如下： 123456789101112131415161718192021222324252627282930313233branches: only: - blog # 这里是你监视的分支，只有blog分支更改才触发自动部署language: node_jssudo: falsenode_js:- '0.12' before_install:- openssl aes-256-cbc -K $encrypted_xxxxxxxxx_key -iv $encrypted_xxxxxxx_iv -in doc/travis.enc -out ~/.ssh/id_rsa -d- chmod 600 ~/.ssh/id_rsa- eval $(ssh-agent)- ssh-add ~/.ssh/id_rsa- cp doc/ssh_config ~/.ssh/config- git config --global user.name \"yourname\"- git config --global user.email youremail- git clone -b master git@github.com:yourname/yourrepo.git .deploy_gitinstall:- npm install hexo-cli -g- npm install- npm install hexo-generator-feed --save- npm install hexo-generator-sitemap --save- npm install hexo-deployer-git --savescript:- hexo clean- hexo g- hexo d Travis CI使用Token 连接GitHub 安装travisTravis安装需要Ruby环境，所有需要安装Ruby,并且需要安装rubygems插件。 12# 安装travisgem isntall travis 新建配置文件首先打开博客项目文件夹，在项目根目录新建.travis.yml配置文件。 12$ cd 博客项目文件夹根目录$ touch .travis.yml 登录travis1travis login --auto 然后会提示输入github的用户名和密码。 新建变量在项目根目录下执行: 123# 这里的 REPO_TOKEN 是变量名,在后面的配置文件中会用到# TOKEN 是上面github生成的Tokentravis encrypt 'REPO_TOKEN=&lt;TOKEN&gt;' --add 此操作会在.travis.yml文件中添加下面的信息 123env:global: secure: fxBE17yzFhC2+FjwVLYbgIhggyfliv3dFCDozTJD7U3n 编辑配置文件​ 打开Travis配置文件.travis.yml，添加如下信息： 1234567891011121314151617181920212223242526272829language: node_jsnode_js:- \"4\" # nodejs的版本branches: only: - dev # 设置自动化部署的源码分支env: global: secure: [加密后的Token]before_install:- export TZ='Asia/Shanghai' # 设置时区- npm install -g hexo- npm install -g hexo-clibefore_script:# 设置github账户信息- git config --global user.name \"SeayXu\" #设置github用户名- git config --global user.email SeayXu@163.com #设置github用户邮箱# github仓库操作- sed -i'' \"s~git@github.com:SeayXu/seayxu.github.io.git~https://$&#123;REPO_TOKEN&#125;:x-oauth-basic@github.com/SeayXu/seayxu.github.io.git~\" _config.yml# 安装依赖组件install:- npm install# 执行的命令script:- hexo clean- hexo generate# 执行的成功后执行 after_success:- hexo deploy 完整配置文件可以参考这个。 转载备用，这个我没配置，因为手上没Lunix系统，等回头装个的虚拟机尝试下，我是用AppVeyor。","categories":[{"name":"网络技术","slug":"网络技术","permalink":"https://ycg31.oschina.io/categories/网络技术/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ycg31.oschina.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://ycg31.oschina.io/tags/hexo/"},{"name":"Travis","slug":"Travis","permalink":"https://ycg31.oschina.io/tags/Travis/"}]},{"title":"GIT相关命令","slug":"GIT相关命令","date":"2017-08-19T19:24:09.000Z","updated":"2017-08-20T05:46:13.694Z","comments":true,"path":"2017/08/20/GIT相关命令/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/GIT相关命令/","excerpt":"","text":"查看所有分支1git branch -a 查看本地分支1git branch 查看远程分支123git remote git remote -v # 带详细信息 添加远程仓库123git remote add [shortname][url]git remote add pb git://github.com/paulboone/ticgit.git #名字为pb 地址为git://github.com/paulboone/ticgit.git 创建分支1git branch test # text为分支名称 切换分支1git checkout test 当前分支推送到远程分支1git checkout test 删除本地分支123git branch -d xxxxx或 git br -d xxxxx 删除远程版本1git push origin :br-1.0.0 删除远程分支123git branch -r -d origin/branch-name git push origin :branch-name #推送一个空的本地分支到远程分支就是删除远程分支","categories":[{"name":"网络技术","slug":"网络技术","permalink":"https://ycg31.oschina.io/categories/网络技术/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ycg31.oschina.io/tags/git/"}]},{"title":"使用Travis自动部署hexo","slug":"使用Travis自动部署hexo","date":"2017-08-19T19:22:09.000Z","updated":"2017-08-20T05:46:11.138Z","comments":true,"path":"2017/08/20/使用Travis自动部署hexo/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/使用Travis自动部署hexo/","excerpt":"","text":"转载自http://blog.csdn.net/xuezhisdc/article/details/53130423 新建Personal Access Token 点击右上角头像旁边的三角，在菜单中点击“Setting”，进入设置页面。 点击左侧栏的最下面的“Personal access tokens”，创建Personal access tokens。 点击右上角的“Generate new token”，输入用户密码，进入“New personal access token”页面。 设置Token description（其实就是名称），选择相应的权限，如下图所示。 点击“Generate token”按钮，生成Personal access tokens。如下图中红线标注的部分。注意：这行token只会在刚刚创建完成后显示一次，以后不再显示。因此，复制并保存到本地。 配置Travis CI登录并配置Travis CI Travis CI是目前新兴的开源持续集成构建项目。可以直接使用GitHub账号登录。 将鼠标放在用户名上，在弹出的菜单中点击“Accounts”，将会显示你在GitHub上的仓库。如下图所示。 找到自己的博客项目，点击X号，将其变成√号。再点击右侧的齿轮，进入该仓库的配置页面。 在项目的设置中开启Build only if .travis.yml is present这一项。如下图所示。 本地安装Travis 首先安装Ruby，直接官网下载，双击安装就OK了。 在Windows下，安装travis之前，需要解决一个问题：SSL证书问题，否则不能成功安装。详情请点击该链接：参考教程。 修复好上述问题后，执行下面的命令安装travis。 12# 安装travisgem isntall travis1212 创建并修改配置文件 打开博客项目文件夹，在项目根目录新建.travis.yml配置文件。 12cd 博客项目文件夹根目录touch .travis.yml1212 执行下面的命令，加密上面生成的Personal access tokens，并添加到.travis.yml配置文件。 123# 这里的 REPO_TOKEN 是变量名,在后面的配置文件中会用到# TOKEN 是上面github生成的Tokentravis encrypt 'REPO_TOKEN=&lt;TOKEN&gt;' --add123123 上述命令指向完后，.travis.yml配置文件的内容如下所示。 123env: global: secure: F/gYu+bVe3aWs6YnuB5PNZLEmHH4CGf0najk8JI3/N+SFL0TH8tyYg+O1sXR3EIg.....省略.....iwr5HQG/G3fdL4JcXiAJIm/iH9ndDyGV5EGR1CmseNGNWrwnRZ7tlKE=123123 使用本地编辑器打开.travis.yml配置文件，将其修改成如下所示的内容。注意：有些内容是你自己的!!! 1234567891011121314151617181920212223242526272829303132333435363738language: node_jsnode_js:- \"4\" # nodejs的版本branches: only: - dev # 设置自动化部署的源码分支# ------------------------------------------------# 下面是你的Token加密信息，不要替换# ------------------------------------------------env: global: secure: F/gYu+bVe3aWs6Yn.....省略..../iH9ndDyGV5EGR1CmseNGNWrwnRZ7tlKE=before_install:- export TZ='Asia/Shanghai' - npm install -g hexo- npm install -g hexo-cli before_script:# ------------------------------------------------# 设置github账户信息 注意修改成自己的信息# ------------------------------------------------- git config --global user.name \"xuezhisd\"- git config --global user.email xuezhi@126.com # ------------------------------------------------# github仓库操作 注意将仓库修改成自己的# ------------------------------------------------- sed -i'' \"s~git@github.com:xuezhisd/xuezhisd.github.io.git~https://$&#123;REPO_TOKEN&#125;:x-oauth-basic@github.com/xuezhisd/xuezhisd.github.io.git~\" _config.yml# 安装依赖组件install:- npm install# 执行的命令script:- hexo clean- hexo generate# 执行的成功后执行 after_success:- hexo deploy12345678910111213141516171819202122232425262728293031323334353637381234567891011121314151617181920212223242526272829303132333435363738 1至此，Travis CI已经配置完成了。 创建仓库，推送到GitHub 新建仓库blog。 12git init blogcd blog1212 将原来博客目录下的以下内容复制到blog文件夹中。 修改.gitignore文件，取消对node_modules文件夹的忽略。（即删除对应的行） 关联GitHub上的远程仓库。 12# 将github仓库改为自己的博客仓库git remote add origin git@github.com:xuezhisd/xuezhisd.github.io.git1212 提交本地修改，推送到GitHub上。 123456# 添加文件到暂存区git add .# 提交修改git commit -m \"test travis\"# 推送至远程仓库的dev分支git push -u origin dev123456123456 push本地的代码至远程仓库之后，在https://travis-ci.org 后台查看相关情况。如果如下图所示，就代表成功了。","categories":[{"name":"网络技术","slug":"网络技术","permalink":"https://ycg31.oschina.io/categories/网络技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ycg31.oschina.io/tags/hexo/"},{"name":"Travis","slug":"Travis","permalink":"https://ycg31.oschina.io/tags/Travis/"}]},{"title":"（转）Hexo添加文章时自动打开编辑器","slug":"（转）Hexo添加文章时自动打开编辑器","date":"2017-08-19T19:20:09.000Z","updated":"2017-08-20T05:42:26.919Z","comments":true,"path":"2017/08/20/（转）Hexo添加文章时自动打开编辑器/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/（转）Hexo添加文章时自动打开编辑器/","excerpt":"","text":"在Hexo中新建一篇博文非常简单，只需要在命令行中键入以下命令然后回车即可： 1hexo new \"The title of your blog\" 此后Hexo便会在Hexo的根目录的source文件夹下的_posts目录下自动帮你创建相应的md文件。然后我们打开该目录，找到刚刚Hexo自动生成的文件打开编辑即可。 但是当我们的博文比较多，这样我们就需要在成堆的Markdown文件中找到刚才自动生成的文件，这样做显然是一件比较痛苦的事情。 首先在Hexo目录下的scripts目录中创建一个JavaScript脚本文件。 如果没有这个scripts目录，则新建一个。 scripts目录新建的JavaScript脚本文件可以任意取名。 通过这个脚本，我们用其来监听hexo new这个动作，并在检测到hexo new之后，执行编辑器打开的命令。 如果你是windows平台的Hexo用户，则将下列内容写入你的脚本： 1234567891011var spawn = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; spawn('start \"markdown编辑器绝对路径.exe\" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; spawn('start \"markdown编辑器绝对路径.exe\" ' + data.path);&#125;); 如果你是Mac平台Hexo用户，则将下列内容写入你的脚本： 12345678910var exec = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; exec('open -a \"markdown编辑器绝对路径.app\" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; exec('open -a \"markdown编辑器绝对路径.app\" ' + data.path);&#125;); 保存并退出脚本之后，在命令行中键入： 1hexo new \"auto open editor test\" 是不是就顺利的自动打开了自动生成的md文件啦~ Enjoy it！ 本文作者： 夏末 本文链接： https://notes.wanghao.work/2015-06-29-Hexo添加文章时自动打开编辑器.html 版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"网站相关","slug":"网站相关","permalink":"https://ycg31.oschina.io/categories/网站相关/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ycg31.oschina.io/tags/hexo/"}]},{"title":"CentOS6上安装V2ray","slug":"CentOS6上安装V2ray","date":"2017-08-19T09:20:09.000Z","updated":"2017-08-20T06:55:45.980Z","comments":true,"path":"2017/08/19/CentOS6上安装V2ray/","link":"","permalink":"https://ycg31.oschina.io/2017/08/19/CentOS6上安装V2ray/","excerpt":"","text":"Centos6下的部署 先说明下，V2Ray提供的一键安装脚本自带守护进程，意思是如果V2Ray如果意外中止，会自动重新启动，这样使用非常方便，但是Centos6下我这种Ctrl CV党实在是不会自己写脚本，采用的是简易运行方式，所以推荐尽量能采用2.1的步骤来安装。 首先我们打开作者的Github项目，找到最新版的V2ray的下载地址 1https://github.com/v2ray/v2ray-core/releases 目前最新版是v2.19，我们找到对应的v2ray-linux-64.zip文件，复制链接地址： 1https://github.com/v2ray/v2ray-core/releases/download/v2.19/v2ray-linux-64.zip 然后我们Root用户Putty登录服务器，root目录下下载文件，代码如下： 1wget https://github.com/v2ray/v2ray-core/releases/download/v2.19/v2ray-linux-64.zip 下载完毕后，我们解压zip文件 1unzip v2ray-linux-64.zip 目录下会多一个目录名，v2ray-v2.19-linux-64（版本不同目录名有版本号的差别），为了后面操作方便，我们把目录名更名 1mv v2ray-v2.19-linux-64 v2ray 进入目录，并对v2ray文件授权123cd /root/v2raychmod +x v2ray 这时候v2ray就能使用了，但是运行v2ray，一旦关闭putty，v2ray就会自动关闭，所以我们需要后台运行，这里采用nohup的方式。123cd /root/v2raynohup ./v2ray &amp; 停止V2ray服务也很简单1killall v2ray 编辑rc.local文件，添加开机启动V2ray1vi /etc/rc.d/rc.local 打开后添加两行123cd /root/v2raynohup ./v2ray &amp; 到这里安装就成功了。下面我们进入下一步，编辑配置文件。 如果使用官网的一键安装脚本无法启动的，可以使用下面这个解决，来自于官网Issues 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#!/bin/sh## v2ray Startup script for v2ray## chkconfig: - 24 76# processname: v2ray# pidfile: /var/run/v2ray.pid# description: V2Ray proxy services#### BEGIN INIT INFO# Provides: v2ray# Required-Start: $network $local_fs $remote_fs# Required-Stop: $remote_fs# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: V2Ray proxy services# Description: V2Ray proxy services### END INIT INFODESC=v2rayNAME=v2rayDAEMON=/usr/bin/v2ray/v2rayPIDFILE=/var/run/$NAME.pidLOCKFILE=/var/lock/subsys/$NAMESCRIPTNAME=/etc/init.d/$NAMERETVAL=0DAEMON_OPTS=\"-config /etc/v2ray/config.json\"# Exit if the package is not installed[ -x $DAEMON ] || exit 0# Read configuration variable file if it is present[ -r /etc/default/$NAME ] &amp;&amp; . /etc/default/$NAME# Source function library.. /etc/rc.d/init.d/functionsstart() &#123; local pids=$(pgrep -f $DAEMON) if [ -n \"$pids\" ]; then echo \"$NAME (pid $pids) is already running\" RETVAL=0 return 0 fi echo -n $\"Starting $NAME: \" mkdir -p /var/log/v2ray $DAEMON $DAEMON_OPTS 1&gt;/dev/null 2&gt;&amp;1 &amp; echo $! &gt; $PIDFILE sleep 2 pgrep -f $DAEMON &gt;/dev/null 2&gt;&amp;1 RETVAL=$? if [ $RETVAL -eq 0 ]; then success; echo touch $LOCKFILE else failure; echo fi return $RETVAL&#125;stop() &#123; local pids=$(pgrep -f $DAEMON) if [ -z \"$pids\" ]; then echo \"$NAME is not running\" RETVAL=0 return 0 fi echo -n $\"Stopping $NAME: \" killproc -p $&#123;PIDFILE&#125; $&#123;NAME&#125; RETVAL=$? echo [ $RETVAL = 0 ] &amp;&amp; rm -f $&#123;LOCKFILE&#125; $&#123;PIDFILE&#125;&#125;reload() &#123; echo -n $\"Reloading $NAME: \" killproc -p $&#123;PIDFILE&#125; $&#123;NAME&#125; -HUP RETVAL=$? echo&#125;rh_status() &#123; status -p $&#123;PIDFILE&#125; $&#123;DAEMON&#125;&#125;# See how we were called.case \"$1\" in start) rh_status &gt;/dev/null 2&gt;&amp;1 &amp;&amp; exit 0 start ;; stop) stop ;; status) rh_status RETVAL=$? ;; restart) stop start ;; reload) reload ;; *) echo \"Usage: $SCRIPTNAME &#123;start|stop|status|reload|restart&#125;\" &gt;&amp;2 RETVAL=2 ;;esacexit $RETVAL Save as /etc/init.d/v2ray and then excute: 123$ sudo chmod +x /etc/init.d/v2ray$ sudo chkconfig v2ray on$ sudo service v2ray start","categories":[{"name":"代理技术","slug":"代理技术","permalink":"https://ycg31.oschina.io/categories/代理技术/"}],"tags":[{"name":"v2ray","slug":"v2ray","permalink":"https://ycg31.oschina.io/tags/v2ray/"}]},{"title":"V2ray使用TLS","slug":"V2ray使用TLS","date":"2017-08-19T06:20:09.000Z","updated":"2017-08-20T05:41:41.701Z","comments":true,"path":"2017/08/19/V2ray使用TLS/","link":"","permalink":"https://ycg31.oschina.io/2017/08/19/V2ray使用TLS/","excerpt":"","text":"1. TLS从 v1.19 起引入了 TLS，TLS 中文译名是传输层安全，如果你没听说过，请 Google 了解一下。以下给出些我认为介绍较好的文章链接： SSL/TLS协议运行机制的概述 传输层安全协议 Shadowsocks 的作者 clowwindy 却认为翻墙不该用 SSL。那么到底该不该用？对此我不作评论，各位自行思考。这里我只教大家如何开启 TLS。 1.1. 注册一个域名如果已经注册有域名了可以跳过。 域名有免费的有付费的，总体来说付费的会优于免费的，具体差别请 Google。如果你不舍得为一个域名每年花点钱，用个免费域名也可以。为了方便，这里我将以免费域名为例。 关于如何注册一个免费域名，我发现有一位网友写得很详细，就不多说了。请参考： 教你申请.tk/.ml/.cf/.gq/.ga等免费域名 至于注册其它付费的域名请 Google 吧，差不多都是大同小异的。 注册好域名之后务必记得设置 DNS 解析到你的 VPS ! 据了解，在 freenom 注册的域名在对应的 IP 上要有一个网站，否则注册之后域名会被回收。如果您只是想用免费域名在 V2Ray 用一下 TLS，又不愿意（懒得、不会）建站，建议您看看您的亲朋好友谁有手上有域名的，向他们要一个二级域名就行了 以下假设注册的域名为 mydomain.me，请将之替换成自己的域名。 1.2. 证书生成使用 TLS 需要证书，证书也有免费付费的，同样的这里使用免费证书，证书认证机构为 Let’s Encrypt。 证书的生成有许多方法，这里使用的是比较简单的方法：使用 acme.sh 脚本生成，本部分说明部分内容参考于acme.sh README。 证书有两种，一种是 ECC 证书（内置公钥是 ECDSA 公钥），一种是 RSA 证书（内置 RSA 公钥）。简单来说，同等长度 ECC 比 RSA 更安全,也就是说在具有同样安全性的情况下，ECC 的密钥长度比 RSA 短得多（加密解密会更快）。但问题是 ECC 的兼容性会差一些，Android 4.x 以下和 Windows XP 不支持。只要您的设备不是非常老的老古董，强烈建议使用 ECC 证书。 以下将给出这两类证书的生成方法，请大家根据自身的情况自行选择其中一种证书类型。 证书生成只需在服务器上操作。 1.2.1. 安装 acme.sh执行以下命令，acme.sh 会安装到 ~/.acme.sh 目录下。 1234567891011121314151617181920$ curl https://get.acme.sh | sh% Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 671 100 671 0 0 680 0 --:--:-- --:--:-- --:--:-- 679% Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 112k 100 112k 0 0 690k 0 --:--:-- --:--:-- --:--:-- 693k[Fri 30 Dec 01:03:32 GMT 2016] Installing from online archive.[Fri 30 Dec 01:03:32 GMT 2016] Downloading https://github.com/Neilpang/acme.sh/archive/master.tar.gz[Fri 30 Dec 01:03:33 GMT 2016] Extracting master.tar.gz[Fri 30 Dec 01:03:33 GMT 2016] Installing to /home/user/.acme.sh[Fri 30 Dec 01:03:33 GMT 2016] Installed to /home/user/.acme.sh/acme.sh[Fri 30 Dec 01:03:33 GMT 2016] Installing alias to '/home/user/.profile'[Fri 30 Dec 01:03:33 GMT 2016] OK, Close and reopen your terminal to start using acme.sh[Fri 30 Dec 01:03:33 GMT 2016] Installing cron jobno crontab for userno crontab for user[Fri 30 Dec 01:03:33 GMT 2016] Good, bash is found, so change the shebang to use bash as preferred.[Fri 30 Dec 01:03:33 GMT 2016] OK[Fri 30 Dec 01:03:33 GMT 2016] Install success! 安装成功后执行 source ~/.bashrc 以确保脚本所设置的命令别名生效。 如果安装报错，那么可能是因为系统缺少 acme.sh 所需要的依赖项，acme.sh 的依赖项主要是 netcat(nc)，我们通过以下命令来安装这些依赖项，然后重新安装一遍 acme.sh: 1$ sudo apt-get -y install netcat 1.2.2. 使用 acme.sh 生成证书证书生成执行以下命令生成证书： 以下的命令会临时监听 80 端口，请确保执行该命令前 80 端口没有使用 1234567891011121314151617181920212223242526272829$ sudo ~/.acme.sh/acme.sh --issue -d mydomain.me --standalone -k ec-256[Fri Dec 30 08:59:12 HKT 2016] Standalone mode.[Fri Dec 30 08:59:12 HKT 2016] Single domain='mydomain.me'[Fri Dec 30 08:59:12 HKT 2016] Getting domain auth token for each domain[Fri Dec 30 08:59:12 HKT 2016] Getting webroot for domain='mydomain.me'[Fri Dec 30 08:59:12 HKT 2016] _w='no'[Fri Dec 30 08:59:12 HKT 2016] Getting new-authz for domain='mydomain.me'[Fri Dec 30 08:59:14 HKT 2016] The new-authz request is ok.[Fri Dec 30 08:59:14 HKT 2016] mydomain.me is already verified, skip.[Fri Dec 30 08:59:14 HKT 2016] mydomain.me is already verified, skip http-01.[Fri Dec 30 08:59:14 HKT 2016] mydomain.me is already verified, skip http-01.[Fri Dec 30 08:59:14 HKT 2016] Verify finished, start to sign.[Fri Dec 30 08:59:16 HKT 2016] Cert success.-----BEGIN CERTIFICATE-----MIIEMTCCAxmgAwIBAgISA1+gJF5zwUDjNX/6Xzz5fo3lMA0GCSqGSIb3DQEBCwUAMEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQDExpMZXQncyBFbmNyeXB0IEF1dGhvcml0eSBYMzAeFw0xNjEyMjkyMzU5MDBaFw0xNzAzMjkyMzU5MDBaMBcxFTATBgNVBAMTDHdlYWtzYW5kLmNvbTBZMBMGByqGSM49****************************************************************4p40tm0aMB837XQ9jeAXvXulhVH/7/wWZ8/vkUUvuHSCYHagENiq/3DYj4a85Iw9+6u1r7atYHJ2VwqSamiyTGDQuhc5wdXIQxY/YQQqkAmn5tLsTZnnOavc4plANT40zweiG8vcIvMVnnkM0TSz8G1yzv1nOkruN3ozQkLMu6YS7lk/ENBN7DBtYVSmJeU2VAXE+zgRaP7JFOqK6DrOwhyE2LSgae83Wq/XgXxjfIo1Zmn2UmlE0sbdNKBasnf9gPUI45eltrjcv8FCSTOUcT7PWCa3-----END CERTIFICATE-----[Fri Dec 30 08:59:16 HKT 2016] Your cert is in /root/.acme.sh/mydomain.me_ecc/mydomain.me.cer[Fri Dec 30 08:59:16 HKT 2016] Your cert key is in /root/.acme.sh/mydomain.me_ecc/mydomain.me.key[Fri Dec 30 08:59:16 HKT 2016] The intermediate CA cert is in /root/.acme.sh/mydomain.me_ecc/ca.cer[Fri Dec 30 08:59:16 HKT 2016] And the full chain certs is there: /root/.acme.sh/mydomain.me_ecc/fullchain.cer -k 表示密钥长度，后面的值可以是 ec-256 、ec-284、2048、3072、4096、8192，带有 ec 表示生成的是 ECC 证书，没有则是 RSA 证书。在安全性上 256 位的 ECC 证书等同于 3072 位的 RSA 证书。 证书更新由于 Let’s Encrypt 的证书有效期只有 3 个月，因此需要 90 天至少要更新一次证书，acme.sh 脚本会每 60 天自动更新证书。也可以手动更新。 手动更新 ECC 证书，执行： 1$ sudo ~/.acme.sh/acme.sh --renew -d mydomain.com --force --ecc 如果是 RSA 证书则执行： 1$ sudo ~/.acme.sh/acme.sh --renew -d mydomain.com --force 1.2.3. 安装证书和密钥ECC 证书将证书和密钥安装到 /etc/v2ray 中： 1$ sudo ~/.acme.sh/acme.sh --installcert -d mydomain.me --fullchainpath /etc/v2ray/v2ray.crt --keypath /etc/v2ray/v2ray.key --ecc RSA 证书1$ sudo ~/.acme.sh/acme.sh --installcert -d mydomain.me --fullchainpath /etc/v2ray/v2ray.crt --keypath /etc/v2ray/v2ray.key 注意：无论什么情况，密钥(即上面的v2ray.key)都不能泄漏，如果你不幸泄漏了密钥，可以使用 acme.sh 将原证书吊销，再生成新的证书，吊销方法请自行参考 acme.sh 的手册 1.3. 配置 V2Ray1.3.1. 服务器123456789101112131415161718192021222324252627282930&#123; \"inbound\": &#123; \"port\": 443, // 建议使用 443 端口 \"protocol\": \"vmess\", \"settings\": &#123; \"clients\": [ &#123; \"id\": \"23ad6b10-8d1a-40f7-8ad0-e3e35cd38297\", \"alterId\": 64 &#125; ] &#125;, \"streamSettings\": &#123; \"network\": \"tcp\", \"security\": \"tls\", // security 要设置为 tls 才会启用 TLS \"tlsSettings\": &#123; \"certificates\": [ &#123; \"certificateFile\": \"/etc/v2ray/v2ray.crt\", //证书文件 \"keyFile\": \"/etc/v2ray/v2ray.key\" //密钥文件 &#125; ] &#125; &#125; &#125;, \"outbound\": &#123; \"protocol\": \"freedom\", \"settings\": &#123;&#125; &#125;&#125; 1.3.2. 客户端123456789101112131415161718192021222324252627282930&#123; \"inbound\": &#123; \"port\": 1080, \"protocol\": \"socks\", \"settings\": &#123; \"auth\": \"noauth\" &#125; &#125;, \"outbound\": &#123; \"protocol\": \"vmess\", \"settings\": &#123; \"vnext\": [ &#123; \"address\": \"mydomain.me\", \"port\": 443, \"users\": [ &#123; \"id\": \"23ad6b10-8d1a-40f7-8ad0-e3e35cd38297\", \"alterId\": 64 &#125; ] &#125; ] &#125;, \"streamSettings\": &#123; \"network\": \"tcp\", \"security\": \"tls\" // 客户端的 security 也要设置为 tls &#125; &#125;&#125; 1.4. 验证一般来说，按照以上步骤操作完成，V2Ray 客户端能够正常联网说明 TLS 已经成功启用。但要是有个可靠的方法来验证是否正常开启 TLS 无疑更令人放心。 验证的方法有很多，我仅介绍一种小白化一点的，便是 Qualys SSL Labs’s SSL Server Test。 注意：使用 Qualys SSL Labs’s SSL Server Test 要求使用 443 端口，意味着你服务器配置的 inbound.port 应当是 443 打开 Qualys SSL Labs’s SSL Server Test，在 Hostname 中输入你的域名，点提交，过一会结果就出来了。 这是对于你的 TLS/SSL 的一个总体评分，我这里评分为 A，看来还不错。有这样的界面算是成功了。 这是关于证书的信息。从图中可以看出，我的这个证书有效期是从 2016 年 12 月 27 号到 2017 年的 3 月 27 号，密钥是 256 位的 ECC，证书签发机构是 Let’s Encrypt，重要的是最后一行，Trusted 为 Yes,表明我这个证书可信。 1.5. 温馨提醒不要想当然地把在 SS 和 SSR 的观念带过来，更不要被别人轻飘飘的一句话误导，V2Ray 的 TLS 不是伪装！不是混淆！这是真正的 TLS！因此才需要域名需要证书。后文提到的 WS(WebSocks) 也不是伪装。","categories":[{"name":"代理技术","slug":"代理技术","permalink":"https://ycg31.oschina.io/categories/代理技术/"}],"tags":[{"name":"v2ray","slug":"v2ray","permalink":"https://ycg31.oschina.io/tags/v2ray/"}]},{"title":"Linux TCP加速工具 —— LotServer(锐速母公司) 一键安装脚本","slug":"Linux TCP加速工具 —— LotServer(锐速母公司) 一键安装脚本","date":"2017-08-19T05:20:09.000Z","updated":"2017-08-20T05:50:16.851Z","comments":true,"path":"2017/08/19/Linux TCP加速工具 —— LotServer(锐速母公司) 一键安装脚本/","link":"","permalink":"https://ycg31.oschina.io/2017/08/19/Linux TCP加速工具 —— LotServer(锐速母公司) 一键安装脚本/","excerpt":"","text":"Linux TCP加速工具 —— LotServer(锐速母公司) 一键安装脚本锐速(ServerSpeeder)可以说是LotServer的马甲，是针对民用的，而LotServer则是针对企业用户的，锐速现在基本上已经关了，而这个LotServer还在持续运营。 Only for Linux. 从根本原因上解决锐速断流问题，断流的根本原因是没有完整破解验证机制。 支持自动检测公网网卡，多个网卡也能区分。 支持自动适配内核 (需锐速支持)。 添加询问是否开启accppp功能 (实测并开启后没有效果)。 默认设置为G口宽带 (听说设置大点可以提高速度)。 支持一键完全卸载 (此脚本安装的无残留)。 所需文件均来自 GiuHub，不放心可自行查阅 (完全公开)。 不支持自动更换内核，请自行更换(网上教程非常多)。 不支持OpenVZ，不需要尝试，会告诉你找不到网卡。 1注意：OVZ虚拟化的VPS并不支持锐速加速器的安装，KVM和XEN应该基本都可以。 作者博客：https://moeclub.org/2017/03/08/14/ 安装文件 appex.zip 为 LotServer 的，(感谢 LotServer 提供安装文件)。 使用前请日常apt-get update / yum update，欢迎反馈bug(各种安装错误)。 使用前建议先查看linux支持内核列表，对照一下系统和内核是否可以安装 LotServer！ 服务器使用uname -r命令来查询内核版本，例如返回的是3.2.0-4-amd64，3.2.0-4-amd64就是你的内核版本。 强烈推荐大家使用 Debian7 x64系统 | 3.2.0-4-amd64内核 ，这个系统和内核无论是锐速、Lotserver还是BBR，除了配置太低的我都没安装失败过！ 安装LotServer1wget --no-check-certificate -qO /tmp/appex.sh \"https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh\" &amp;&amp; bash /tmp/appex.sh 'install' 安装一开始的时候，会提示： 12Press Enter to Continue...# 这个是提示你按回车键继续 如果安装过程中没问题的话，最后会提示： 12345678910Accelerate VPN (PPTP,L2TP,etc.)? [n]:# 是否加速VPN Auto load ServerSpeeder on linux start-up? [y]:# 是否开机启动 Run ServerSpeeder now? [y]:# 是否现在启动锐速 # 全部默认回车即可。 最后出现这样的提示就说明安装并启动成功： 123456789101112[Running Status]ServerSpeeder is running!version 3.11.20.4 [License Information]License 6001ADDF578B6C0E (valid on current device)MaxSession unlimitedMaxTcpAccSession unlimitedMaxBandwidth(kbps) 1024000ExpireDate 2035-12-31....# 以下省略.... 卸载LotServer1wget --no-check-certificate -qO /tmp/appex.sh \"https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh\" &amp;&amp; bash /tmp/appex.sh 'uninstall' 使用说明1234567891011121314/appex/bin/serverSpeeder.sh start# 启动 LotServer /appex/bin/serverSpeeder.sh stop# 停止 LotServer /appex/bin/serverSpeeder.sh restart# 重启 LotServer /appex/bin/serverSpeeder.sh status# 状态查询 /appex/bin/serverSpeeder.sh renewLic# 更新许可 代码托管地址 LotServer 完整使用介绍 PDF手册 安装完了，想要自己修改配置最大化加速效果，那么请看：锐速(ServerSpeeder/LotServer)配置参数简单说明，合理修改配置 提高加速效果 这个LotServer与锐速(ServerSpeeder)的加速区别并不大，不过91yun的破解版因为破解不完整导致会出现断流等情况，而这个 LotServer 则没有这种问题。","categories":[{"name":"代理技术","slug":"代理技术","permalink":"https://ycg31.oschina.io/categories/代理技术/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ycg31.oschina.io/tags/Linux/"},{"name":"速锐","slug":"速锐","permalink":"https://ycg31.oschina.io/tags/速锐/"}]}]}