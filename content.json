{"meta":{"title":"杂记","subtitle":"记录网上生活","description":"有了这个，就不用到处去找重复的了","author":"ycg31","url":"https://ycg31.oschina.io"},"pages":[{"title":"About","date":"2017-08-22T14:24:28.016Z","updated":"2017-08-20T16:25:32.461Z","comments":true,"path":"about/index.html","permalink":"https://ycg31.oschina.io/about/index.html","excerpt":"","text":""},{"title":"Project","date":"2017-08-20T16:26:13.910Z","updated":"2017-08-20T16:25:32.461Z","comments":true,"path":"project/index.html","permalink":"https://ycg31.oschina.io/project/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-08-19T20:00:21.000Z","updated":"2017-08-22T14:25:10.443Z","comments":true,"path":"categories/index.html","permalink":"https://ycg31.oschina.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-08-20T16:25:32.477Z","updated":"2017-08-20T16:25:32.477Z","comments":true,"path":"tags/index.html","permalink":"https://ycg31.oschina.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vedio test","slug":"vedio-test","date":"2017-08-29T17:35:44.000Z","updated":"2017-08-29T17:36:50.331Z","comments":true,"path":"2017/08/30/vedio-test/","link":"","permalink":"https://ycg31.oschina.io/2017/08/30/vedio-test/","excerpt":"","text":"Your user agent does not support the HTML5 Video element.","categories":[{"name":"网络技术","slug":"网络技术","permalink":"https://ycg31.oschina.io/categories/网络技术/"}],"tags":[{"name":"test","slug":"test","permalink":"https://ycg31.oschina.io/tags/test/"}]},{"title":"(转)给 Hexo 添加带滚动监听的文章目录","slug":"给-Hexo-添加带滚动监听的文章目录","date":"2017-08-29T17:23:59.000Z","updated":"2017-08-29T17:27:08.659Z","comments":true,"path":"2017/08/30/给-Hexo-添加带滚动监听的文章目录/","link":"","permalink":"https://ycg31.oschina.io/2017/08/30/给-Hexo-添加带滚动监听的文章目录/","excerpt":"","text":"Hexo 是支持文章目录的，这篇文章就对如何添加目录进行了介绍。 大概几周之前，我把文章目录添加到了博客样式中，随后又添加了滚动监听。最近看面试题的时候，发现原来还可以消除抖动，又涨了见识，并且运用到自己的博客中。 添加 Hexo toc 模块看了 Hexo 的官网教程，发现原来 toc 已经被 Hexo 默认支持了，只需要在模版文件中引入即可，比如像下面： 12345678&lt;div id=\"toc\"&gt; &lt;div class=\"toc-header\"&gt; &lt;i class=\"toc-icon\"&gt;&lt;/i&gt; 文章目录 &lt;/div&gt; // 添加目录模块 &#123;&#123; toc(page.content) &#125;&#125;&lt;/div&gt; toc 这个函数，它可以把 page.content 中可以作为目录（一级二级三级）元素都提取出来，然后按照一定的格式，生成与 content 相对应的文章目录。下面这个格式就是上面生成的结下： 光这样还不行，还需要添加对应的样式，下面是我在 stylus 文件中的样式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#toc&#123; position fixed top 0px left 50% padding 10px 0 10px 0 z-index 2 margin-left 400px margin-top 8px line-height 1.5 background-color rgba(242, 243, 241, 0.6) padding-right 5px width 160px &amp; .toc-icon&#123; font-size 14px position absolute cursor pointer right 0px top 0px padding 10px &#125; &amp; .toc-header&#123; font-weight 700; border none; padding 8px 12px; font-size 20px; position relative &#125; &amp; .close&#123; display none &#125; &amp; .toc&#123; list-style none position relative font-size 16px padding-left 8px overflow-x hidden; &amp; a&#123; color #4a75b5 &amp;:hover&#123; color #ef593e text-decoration none &#125; &#125; &amp; ol, &amp; ul&#123; list-style-type disc &#125; &amp; .toc-child&#123; padding-left 20px font-size 12px display none &amp; span.toc-number&#123; display none &#125; &#125; &amp; .active~.toc-child&#123; display block &#125; &amp; .toc-child.toc-show&#123; display block &#125; &amp; .toc-link&#123; white-space nowrap &#125; &amp; .toc-link.active&#123; color #ef593e &#125; &amp;:before&#123; content ''; display block; position absolute; background #eee; width 3px; top 0; bottom 0; border-radius 5px; left 0; &#125; &#125; @media (max-width: 1100px)&#123; display none &#125;&#125; 效果如下： 关于点击关闭按钮，文章目录就必会的功能就不在此阐述了。 实现滚动监听光添加了目录，还远远是不够的，一个做得很棒的目录，都会有监听滚动并且目录会随着改变。 看了 Bootstrap 提供的 scrollspy 库，有监听功能，貌似效果还不错的样子。因为我博客中包含了 jQuery 库，所以就尝试用 jQuery 自己实现了一个。 介绍实现之前，需要对 Hexo 博客的板块特点进行介绍。 在 post content 中，最终会将 markdown 生成对应的 html，对于一般的 H 标题，生成的格式一般如下： 1234&lt;h2 id=\"添加-Hexo-toc-模块\"&gt; &lt;a href=\"#添加-Hexo-toc-模块\" class=\"headerlink\" title=\"添加 Hexo toc 模块\"&gt;&lt;/a&gt; 添加 Hexo toc 模块&lt;/h2&gt; 在正式的标题之前，一般都会有一个空的 a 标签，它的 class 为 headerlink，可以借助这个来生成一个 $(&#39;.headerlink&#39;) jQuery 对象。然后配合 $(&#39;.toc-link&#39;)，这两个 jQuery 对象就一一对应了。 大致的思路就是首先获取每个 headerlink 距离 top 的高度，存储在数组 headerlinkTop 里，然后监听浏览器的 scroll，当滚动到 headerlinkTop 的某一个元素时，将 toc 按照 i 的位置设置 active： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374var $w = $(window);// 修正响应不及时的问题var HEADFIX = 30;var $toclink = $('.toc-link'), $headerlink = $('.headerlink'), $tocchild = $('.toc-child');// 用来获取 top 数组var headerlinkTop = [];headerlinkTop = $.map($headerlink, function(link) &#123; return $(link.parentNode).offset().top - HEADFIX;&#125;);// 修正参数，将第一个元素置为 -1headerlinkTop[0] = -1;// 最后添加一个 无穷大headerlinkTop.push(Infinity);var pos = 0;var getActive = function(s_top)&#123; for(var i = 0; i &lt; $toclink.length; i++)&#123; var currentTop = headerlinkTop[i]; var nextTop = headerlinkTop[i+1]; if(s_top &gt; currentTop &amp;&amp; s_top &lt;= nextTop)&#123; $toclink.removeClass('active'); $tocchild.removeClass('toc-show'); pos = i; var nowlink = $toclink[i]; $(nowlink).addClass('active'); while($(nowlink.parentNode.parentNode).hasClass('toc-child'))&#123; nowlink = nowlink.parentNode.parentNode; $(nowlink).addClass('toc-show'); &#125; break; &#125; &#125;&#125;getActive($w.scrollTop());// 修复 image load bug// 由于网页已经加载，而图片还未加载完成，导致数组的高度有偏差var link_length = $headerlink.length;var $link_last = link_length &gt; 1 ? $($headerlink[$headerlink.length - 1].parentNode) : null;var fixLoading = function()&#123; if(link_length &gt; 1 )&#123; if(($link_last.offset().top - HEADFIX) - headerlinkTop[link_length - 1] != 0)&#123; headerlinkTop = $.map($headerlink, function(link) &#123; return $(link.parentNode).offset().top - HEADFIX; &#125;); // 修正参数 headerlinkTop[0] = -1; headerlinkTop.push(Infinity); console.log('fix loading bug!'); &#125; &#125;&#125;// callbackvar cb = function()&#123; var scrollTop = $w.scrollTop(); fixLoading(); if(scrollTop &gt; headerlinkTop[pos + 1] || scrollTop &lt;= headerlinkTop[pos])&#123; getActive(scrollTop); console.log('jump!'); &#125;&#125;if(!this.doScroll)&#123; this.doScroll = true; // 监听浏览器滚动 $w.scroll(cb);&#125; 主要还是依靠 hexo 的特性来加以改造，实现了监听。 防抖动关于防抖动函数，可以去看下这个介绍 问题 #3: 函数防抖。 我自己试了一下 scroll 函数，发现随便滚动一下就是是好几百的函数调用： 123456789var cb = function()&#123; console.log('scroll!');//随便一滚动就好几百个 log var scrollTop = $w.scrollTop(); fixLoading(); if(scrollTop &gt; headerlinkTop[pos + 1] || scrollTop &lt;= headerlinkTop[pos])&#123; getActive(scrollTop); console.log('jump!'); &#125;&#125; 把抖动函数拿了过来，实现起来也比较简单，就是利用 setTimeout 函数的特性，如果频率过快的时候，就把上一个定时器给清除，涉及到闭包和定时器的概念，原理很简单： 1234567891011function debounce(fn, delay)&#123; var timer = null, self = this; return function()&#123; var args = arguments; clearTimeout(timer); timer = setTimeout(function()&#123; fn.apply(self, args); &#125;, delay) &#125;&#125; 运用： 1234this.debounce = debounce;// delay 为 50 毫秒，效果还行$w.scroll(this.debounce(cb, 50));// log 日志很少 参考 为Hexo博客添加目录Bootstrap - Scroll spy Plugin3个经常被问到的 JavaScript 面试题","categories":[{"name":"网页技术","slug":"网页技术","permalink":"https://ycg31.oschina.io/categories/网页技术/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://ycg31.oschina.io/tags/jQuery/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://ycg31.oschina.io/tags/JavaScript/"}]},{"title":"stylus预处理入门(一)——选择器","slug":"stylus预处理入门(一)——选择器","date":"2017-08-29T16:58:15.000Z","updated":"2017-08-29T16:59:22.752Z","comments":true,"path":"2017/08/30/stylus预处理入门(一)——选择器/","link":"","permalink":"https://ycg31.oschina.io/2017/08/30/stylus预处理入门(一)——选择器/","excerpt":"","text":"相关网站 官网：stylus 中文文档：stylus中文版参考文档 by 张鑫旭 理解css预处理器：css预处理器初识 by 栓萝卜的棍子 三种css预处理器语言详解：less|sass|stylus by 开源中国 CSS预处理器语言的个人理解 用另外一种可读性高、语法性强的语言来写CSS。stylus可以使用循环、分支、定义变量和函数结构来写css，这样写起来既方便又快捷。 通过一种转换机制将这种语法转化为原生css。每种语言的转化机制也有很多种，可以使用各种语言官网的方法转化，例如less。也可以使用构建工具webpack的stylus-loader来将stylus语言转化为原生css。 stylus的特点 官网可以直接将stylus代码放在官网这一页测试生成原生css（本人硬加上去的特点） 通过缩进来解释语言（喜欢python的geek应该会比较喜欢）。 待补充.. 123body div color white 转化： 123body div &#123; color:#fff;&#125; stylus的优点 类python语法（官网称stylus为pythonic）。 语法灵活（可选的括号，冒号，分号等）。 stylus的缺点 由于其语法灵活的问题，如果没有团队规范，那么就会带来团队开发混乱，维护起来比较麻烦，各种语法混杂。 stylus语法介绍选择器(selectors)缩进(换行缩进表示语句前进)12body color:white; 转化： 123body&#123; color:white;&#125; 同级选择器 element,element 123divp color:white; 转化： 123div,p&#123; color:white;&#125; element element 123div p color:white; 转化： 123div p&#123; color:white;&#125; element &gt;element 123div &gt;p color:white; 转化： 123div &gt;p&#123; color:white;&#125; element +element 123div +p color:white; 转化： 123div +p&#123; color:white;&#125; 例外： 123foo bar baz&gt;span color:white; 注：上面代码的foo bar baz编译器解析有可能是”标签 属性 属性”，有可能是”标签 标签 标签”（有可能是自定义的标签）（编译器只会识别文档结构而不是标签或者属性） 建议写成下面这样（在最后的选择器后面加一个逗号[comma]）： 12foo bar baz,&gt;span 注：上面的同级选择器是这里的优化，没有提到的其他选择器大多数保留原来的语法，或者与上面的语法类似，当然上面提到的选择器也可以使用原来的语法 引用父级选择器 使用&amp;指向父级选择器，有可能是选择器数组，也有可能是单独的一个选择器。 12345divp color:#FFF; &amp;:hover color:#000; 转化： 12345678div,p &#123; color: #fff;&#125;div:hover,p:hover &#123; color: #000;&#125; 解释：其实”&amp;”可以理解为代替了上一层的选择器，比如上面例子，”&amp;”的上一层是”div,p”，这样说比较好理解。 下面是引用父级选择器的另一个例子 123456789101112box-shadow() -webkit-box-shadow arguments -moz-box-shadow arguments box-shadow arguments html.ie8 &amp;, html.ie7 &amp;, html.ie6 &amp; border 2px solid arguments[length(arguments) - 1]body #login box-shadow 1px 1px 3px #eee 转化： 12345678910body #login &#123; -webkit-box-shadow: 1px 1px 3px #eee; -moz-box-shadow: 1px 1px 3px #eee; box-shadow: 1px 1px 3px #eee;&#125;html.ie8 body #login,html.ie7 body #login,html.ie6 body #login &#123; border: 2px solid #eee;&#125; 注：如果想在代码里使用”&amp;”符号而不是stylus的”&amp;”，可以在&amp;字符前加一个反斜杠并加上引号，如下： 1.foo[title*='\\&amp;'] /*.foo[title*='&amp;']*/ 部分引用父级选择器之单层选择器 使用^ [N] 引用第N层父级选择器。如果N是正数，这里的第N层指的是最上层上层选择器到第N层选择器，如果N是负数，这里的第N层指的是最上层选择器到倒数第|N|层选择器。 有&amp;的情况： 123456.foo &amp;__bar width: 10px ^[0]:hover &amp; width: 20px 转化： 123456.foo__bar &#123; width: 10px;&#125;.foo:hover .foo__bar &#123; width: 20px;&#125; 没有&amp;的情况： 123456.foo .bar width: 10px ^[0]:hover &amp; width: 20px 转化： 123456.foo .bar &#123; width: 10px;&#125;.foo:hover .foo .bar &#123; width: 20px;&#125; N为0或者正数则从最上层开始到最下层，N为负数则从最下层开始到最上层。其实第N层的选择器是包含了上一层的选择器的，例如下面的例子，第一层选择器是foo,第二层就是foo bar,第三层是foo bar baz，如此类推（官网说的是嵌套）。 1234567.foo bar baz width: 10px ^[-1]:hover &amp; width: 20px 转化： 123456.foo bar baz &#123; width: 10px;&#125;.foo bar:hover .foo bar baz &#123; width: 20px;&#125; 注：如果写在mixins里的话，推荐将N写成负数。因为你并不知道你在调用哪一层（ 有可能还有隐藏的上层选择器） 部分引用父级选择器之范围选择器 ^ [N..M] 引用第N层选择器到第M层选择器组成的选择器。注：这里有些跟引用单层选择器有点不同，这里的第几层是不包括上层选择器的，具体来看例子感受一下。 1234567.foo bar baz test width: 10px ^[-1]:hover ^[-2..-1] width: 20px 转化： 123456.foo bar baz test &#123; width: 10px;&#125;.foo bar baz:hover baz test &#123; width: 20px;&#125; 其他部分引用父级选择器 最上层父级选择器(~/)，相当于^ [0] 1234.block &amp;__element ~/:hover &amp; color: red 转化： 123.block:hover .block__element &#123; color: #f00;&#125; 相对父级选择器(../) 1234567.foo bar baz test width: 10px ../:hover ^[-1..-2] width: 20px 转化： 123456.foo .bar .baz .test &#123; width: 10px;&#125;.foo .bar .baz:hover .baz .test &#123; width: 20px;&#125; 脱离嵌套的选择器(/) 1234567divp span color #A7A7A7 &amp;:hover, /.is-hovered color #000 转化： 123456789div span,p span &#123; color: #a7a7a7;&#125;div span:hover,p span:hover,.is-hovered &#123; color: #000;&#125; 上面的例子里，转化后的代码.is-hovered已经脱离了嵌套结构了，已经不在任何选择器嵌套里。 选择器的值 selector()获取当前嵌套层的值，selectors()获取从最上层到当前层每一层的选择器的list 123456.foo &amp;:hover class selector() color black span color white 转化： 1234567.foo:hover &#123; class: '.foo:hover'; /*这个是selector()的值*/ color: #000;&#125;.foo:hover span &#123; color: #fff;&#125; 123456.a .b &amp;__c content: selectors() span color white 转化： 123456.a .b__c &#123; content: '.a', '&amp; .b', '&amp;__c';&#125;.a .b__c span &#123; color: #fff;&#125; QUOTE: If you are not moving ahead , you are falling behind.","categories":[{"name":"网页技术","slug":"网页技术","permalink":"https://ycg31.oschina.io/categories/网页技术/"}],"tags":[{"name":"stylus","slug":"stylus","permalink":"https://ycg31.oschina.io/tags/stylus/"},{"name":"css","slug":"css","permalink":"https://ycg31.oschina.io/tags/css/"}]},{"title":"stylus入门使用方法","slug":"stylus入门使用方法","date":"2017-08-29T16:52:15.000Z","updated":"2017-08-29T16:55:39.438Z","comments":true,"path":"2017/08/30/stylus入门使用方法/","link":"","permalink":"https://ycg31.oschina.io/2017/08/30/stylus入门使用方法/","excerpt":"","text":"stylus介绍是个什么鬼？对于开发来说，CSS的弱点在于静态化。我们需要一个真正能提高开发效率的工具，LESS， SASS都在这方面做了一些贡献。 Stylus 是一个CSS的预处理框架，2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，所以 Stylus 是一种新型语言，可以创建健壮的、动态的、富有表现力的CSS。比较年轻，其本质上做的事情与 SASS/LESS 等类似，应该是有很多借鉴，所以近似脚本的方式去写CSS代码。 Stylus默认使用 .styl 的作为文件扩展名，支持多样性的CSS语法。 Stylus功能上更为强壮，和js联系更加紧密。所以我选择 Stylus，SASS 玩儿过一段时间，主要是这玩意依赖ruby运行，所以我放弃使用了。 文档参考官方Stylus API张鑫旭中文翻译Try Stylus! Stylus安装全局安装，安装之前你需要你安装 nodejs 这个怎么安装搜去哦。 1$ npm install stylus -g 这样就算是安装完Stylus了，也可以正常使用Stylus。 123456789101112131415161718192021Usage: stylus [options] [command] [&lt; in [&gt; out]] [file|dir ...]Commands: help &lt;prop&gt; Opens help info for &lt;prop&gt; in your default browser. (OS X only)Options: -u, --use &lt;path&gt; Utilize the stylus plugin at &lt;path&gt; -i, --interactive Start interactive REPL -w, --watch Watch file(s) for changes and re-compile -o, --out &lt;dir&gt; Output to &lt;dir&gt; when passing files -C, --css &lt;src&gt; [dest] Convert CSS input to Stylus -I, --include &lt;path&gt; Add &lt;path&gt; to lookup paths -c, --compress Compress CSS output -d, --compare Display input along with output -f, --firebug Emits debug infos in the generated css that can be used by the FireStylus Firebug plugin -l, --line-numbers Emits comments in the generated CSS indicating the corresponding Stylus line -V, --version Display the version of Stylus -h, --help Display help information 生成CSS命令行中建立一个stylusExample/，再在里面建立 src 目录专门存放 stylus 文件，在里面建立 example.styl 文件。然后在 stylusExample 目录下面执行下面命令 $ stylus --compress src/ 输出compiled src/example.css ，这个时候表示你生成成功了，带上--compress参数表示你生成压缩的CSS文件。 $ stylus --css css/example.css css/out.styl CSS转换成styl$ stylus help box-shadow CSS属性的帮助$ stylus --css test.css 输出基本名一致的.styl文件 grunt生成grunt生成 就比较爽歪歪了，具体grunt怎么玩儿，俺写了个教程Grunt教程-前端自动化 可以学习以下。 stylusExample 目录下创建两个文件，这两个文件是grunt必备文件。 package.json：用于保存项目元数据。Gruntfile.js：用于配置或定义任务、加载 Grunt 插件。 package.json 内容 123456789&#123; \"name\": \"test\", \"version\": \"1.0.0\", \"description\": \"测试的例子\", \"repository\": &#123; \"type\": \"git\", \"url\": \"\" &#125;&#125; 然后安装必备插件，这些插件让stylus文件变更了自动生成，生成到相对应的文件目录中。如果报错你需要在命令行前面加上sudo，给它最大的执行权限。 npm install grunt --save-devnpm install grunt-contrib-watch --save-dev ：监视文件变动，做出相应动作。npm&gt;&gt;npm install grunt-contrib-stylus --save-dev ：stylus编写styl输出css npm&gt;&gt; 安装出现这样的警告 npm WARN package.json test@1.0.0 No README data 可以不理会，如果你看着不舒服，你需要在stylusExample目录下面建立一个 README.md 文件并输入内容。也可命令执行 echo &quot;#stylus 学习&quot; &gt;&gt; README.md 插件执行完毕之后 package.json 文件变成了这样样子滴。 1234567891011121314&#123; \"name\": \"test\", \"version\": \"1.0.0\", \"description\": \"测试的例子\", \"repository\": &#123; \"type\": \"git\", \"url\": \"\" &#125;, \"devDependencies\": &#123; \"grunt\": \"^0.4.5\", \"grunt-contrib-stylus\": \"^0.21.0\", \"grunt-contrib-watch\": \"^0.6.1\" &#125;&#125; 这个时候你需要使用这些插件儿完成你的任务需要在Gruntfile.js里面写你的执行任务。 123456789101112131415161718192021222324252627282930313233/// 包装函数module.exports = function(grunt) &#123; // 任务配置,所有插件的配置信息 grunt.initConfig(&#123; pkg: grunt.file.readJSON('package.json'), stylus:&#123; build: &#123; options: &#123; linenos: false, compress: true &#125;, files: [&#123; 'css/index.css': ['src/index.styl'] &#125;] &#125; &#125;, // watch插件的配置信息 watch: &#123; another: &#123; files: ['css/*','src/*.styl'], tasks: ['stylus'], options: &#123; livereload: 1337 &#125; &#125; &#125; &#125;); // 告诉grunt我们将使用插件 grunt.loadNpmTasks('grunt-contrib-watch'); grunt.loadNpmTasks('grunt-contrib-stylus'); // 告诉grunt当我们在终端中输入grunt时需要做些什么 grunt.registerTask('default', ['watch']);&#125;; 注意读懂上面的哦，目录高对哦，这些没有必要提醒哦，这个时候你可以好好耍一下stylus Stylus应用这个时候真正的开始玩耍了哦。 Try Stylus!stylus 123body,html margin:0 padding:0 编译成 12345body,html &#123; margin: 0; padding: 0;&#125; stylus : 强大的功能丰富的语言 12345678910111213141516171819-pos(type, args) i = 0 position: unquote(type) &#123;args[i]&#125;: args[i + 1] is a 'unit' ? args[i += 1] : 0 &#123;args[i += 1]&#125;: args[i + 1] is a 'unit' ? args[i += 1] : 0absolute() -pos('absolute', arguments)fixed() -pos('fixed', arguments)#prompt absolute: top 150px left 5px width: 200px margin-left: -(@width / 2)#logo fixed: top left 编译成 123456789101112#prompt &#123; position: absolute; top: 150px; left: 5px; width: 200px; margin-left: -100px;&#125;#logo &#123; position: fixed; top: 0; left: 0;&#125; nibStylus插件stylus 123@import 'nib'body background: linear-gradient(20px top, white, black) 编译成 1234567body &#123; background: -webkit-linear-gradient(20px top, #fff, #000); background: -moz-linear-gradient(20px top, #fff, #000); background: -o-linear-gradient(20px top, #fff, #000); background: -ms-linear-gradient(20px top, #fff, #000); background: linear-gradient(20px top, #fff, #000);&#125; Nesting(嵌套)stylus 123header #logo border:1px solid red 编译成 123header #logo &#123; border: 1px solid #f00;&#125; Flexible syntax(灵活的用法)stylus 1234567891011body font 14px/1.5 Helvetica, arial, sans-serif button button.button input[type='button'] input[type='submit'] border-radius 5px header #logo,div font-size:14px 编译成 123456789101112body &#123; font: 14px/1.5 Helvetica, arial, sans-serif;&#125;body button,body button.button,body input[type='button'] &#123; border-radius: 5px;&#125;header #logo,header div &#123; font-size: 14px;&#125; Flexible &amp;(灵活&amp;)stylus 123456789ul li a display: block color: blue padding: 5px html.ie &amp; padding: 6px &amp;:hover color: red 编译成 1234567891011ul li a &#123; display: block; color: #00f; padding: 5px;&#125;html.ie ul li a &#123; padding: 6px;&#125;ul li a:hover &#123; color: #f00;&#125; Functions 方法返回值stylus 1234567border-radius(val) -webkit-border-radius: val -moz-border-radius: val border-radius: valbutton border-radius(5px); 编译成 12345button &#123; -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px;&#125; Transparent mixins不带参数 stylus 1234567border-radius() -webkit-border-radius: arguments -moz-border-radius: arguments border-radius: argumentsbutton border-radius: 5px 10px; 编译成 12345button &#123; -webkit-border-radius: 5px 10px; -moz-border-radius: 5px 10px; border-radius: 5px 10px;&#125; 默认参数不带参数 stylus 12345678add(a, b = a) a + badd(10, 5)// =&gt; 15add(10)// =&gt; 20 函数体通过内置unit()把单位都变成px, 因为赋值在每个参数上，因此，我们可以无视单位换算。 1234567add(a, b = a) a = unit(a, px) b = unit(b, px) a + badd(15%, 10deg)// =&gt; 25 多个返回值通过内置unit()把单位都变成px, 因为赋值在每个参数上，因此，我们可以无视单位换算。 12345sizes() 15px 10pxsizes()[0]// =&gt; 15px Variables(变量)常用方法stylus 1234font-size = 14pxbody font font-size Arial, sans-seri 编译成 123body &#123; font: 14px Arial, sans-seri;&#125; 变量放在属性中stylus 123456#prompt position: absolute top: 150px left: 50% width: w = 200px margin-left: -(w / 2) 编译成 1234567#prompt &#123; position: absolute; top: 150px; left: 50%; width: 200px; margin-left: -100px;&#125; 块属性访问引用stylus 1234#prompt position: absolute width: 200px margin-left: -(@width / 2) 编译成 12345#prompt &#123; position: absolute; width: 200px; margin-left: -100px;&#125; 属性有条件地定义属性stylus:指定z-index值为1，但是，只有在z-index之前未指定的时候才这样： 12345678910position() position: arguments z-index: 1 unless @z-index#logo z-index: 20 position: absolute#logo2 position: absolute 编译成 12345678#logo &#123; z-index: 20; position: absolute;&#125;#logo2 &#123; position: absolute; z-index: 1;&#125; 向上冒泡stylus:属性会“向上冒泡”查找堆栈直到被发现，或者返回null（如果属性搞不定）下面这个例子，@color被弄成了blue. 1234567body color: red ul li color: blue a background-color: @color 编译成 123456789body &#123; color: #f00;&#125;body ul li &#123; color: #00f;&#125;body ul li a &#123; background-color: #00f;&#125; Iteration(迭代)stylus 1234table for row in 1 2 3 4 5 tr:nth-child(&#123;row&#125;) height: 10px * row 编译成 123456789101112131415table tr:nth-child(1) &#123; height: 10px;&#125;table tr:nth-child(2) &#123; height: 20px;&#125;table tr:nth-child(3) &#123; height: 30px;&#125;table tr:nth-child(4) &#123; height: 40px;&#125;table tr:nth-child(5) &#123; height: 50px;&#125; Interpolation(插值)stylus 123456789vendors = webkit moz o ms officialborder-radius() for vendor in vendors if vendor == official border-radius: arguments else -&#123;vendor&#125;-border-radius: arguments#content border-radius: 5px 编译成 1234567#content &#123; -webkit-border-radius: 5px; -moz-border-radius: 5px; -o-border-radius: 5px; -ms-border-radius: 5px; border-radius: 5px;&#125; Operators(运算符)运算符优先级下表运算符优先级，从最高到最低： 12345678910111213141516. [] ! ~ + - is defined ** * / % + - ... .. &lt;= &gt;= &lt; &gt; in == is != is not isnt is a &amp;&amp; and || or ?: = := ?= += -= *= /= %= not if unless @import@import &quot;reset.css&quot; 当使用@import没有.css扩展，会被认为是Stylus片段（如：@import &quot;mixins/border-radius&quot;）。 @import工作原理为：遍历目录队列，并检查任意目录中是否有该文件（类似node的require.paths）。该队列默认为单一路径，从filename选项的dirname衍生而来。 因此，如果你的文件名是/tmp/testing/stylus/main.styl，导入将显现为/tmp/testing/stylus/。 @import也支持索引形式。这意味着当你@import blueprint, 则会理解成blueprint.styl或blueprint/index.styl. 对于库而言，这很有用，既可以展示所有特征与功能，同时又能导入特征子集。 @font-facestylus 1234567@font-face font-family Geo font-style normal src url(fonts/geo_sans_light/GensansLight.ttf).ingeo font-family Geo 编译成 12345678@font-face &#123; font-family: Geo; font-style: normal; src: url(\"fonts/geo_sans_light/GensansLight.ttf\");&#125;.ingeo &#123; font-family: Geo;&#125; @mediastylus 1234@media print #header #footer display none 编译成 123456@media print &#123; #header, #footer &#123; display: none; &#125;&#125; @keyframesstylus 1234567@keyframes pulse 0% background-color red transform scale(1.0) rotate(0deg) 33% background-color blue -webkit-transform scale(1.1) rotate(-5deg) 编译成 12345678910111213141516171819202122232425262728293031323334353637383940@-moz-keyframes pulse &#123; 0% &#123; background-color: #f00; transform: scale(1) rotate(0deg); &#125; 33% &#123; background-color: #00f; -webkit-transform: scale(1.1) rotate(-5deg); &#125;&#125;@-webkit-keyframes pulse &#123; 0% &#123; background-color: #f00; transform: scale(1) rotate(0deg); &#125; 33% &#123; background-color: #00f; -webkit-transform: scale(1.1) rotate(-5deg); &#125;&#125;@-o-keyframes pulse &#123; 0% &#123; background-color: #f00; transform: scale(1) rotate(0deg); &#125; 33% &#123; background-color: #00f; -webkit-transform: scale(1.1) rotate(-5deg); &#125;&#125;@keyframes pulse &#123; 0% &#123; background-color: #f00; transform: scale(1) rotate(0deg); &#125; 33% &#123; background-color: #00f; -webkit-transform: scale(1.1) rotate(-5deg); &#125;&#125; CSS字面量(CSS Literal)stylus 12345@css &#123; body &#123; font: 14px; &#125;&#125; 编译成 123body &#123; font: 14px;&#125; 工具 sublime 插件 Stylus Clean Completions 代码提示 Stylus","categories":[{"name":"网页技术","slug":"网页技术","permalink":"https://ycg31.oschina.io/categories/网页技术/"}],"tags":[{"name":"stylus","slug":"stylus","permalink":"https://ycg31.oschina.io/tags/stylus/"},{"name":"css","slug":"css","permalink":"https://ycg31.oschina.io/tags/css/"}]},{"title":"自定义HEXO站内搜索Javascript+json","slug":"自定义HEXO站内搜索Javascript-json","date":"2017-08-29T16:47:27.000Z","updated":"2017-08-29T16:49:24.409Z","comments":true,"path":"2017/08/30/自定义HEXO站内搜索Javascript-json/","link":"","permalink":"https://ycg31.oschina.io/2017/08/30/自定义HEXO站内搜索Javascript-json/","excerpt":"","text":"开始之前目前很多Hexo博客都用的Swiftype和Algolia等第三方搜索服务。其实针对无数据库的情况下，Hexo本身也提供了两个插件来生成数据文件作为数据源：hexo-generator-search生成xml格式的数据文件。hexo-generator-json-content 生成json格式的数据文件。今天的主角是hexo-generator-json-content，对于 Javascript语言来说还是解析 json 更方便，如果需要用 xml 做数据文件也可以使用已有的atom.xml。 1.安装1$ npm install hexo-generator-json-content@2.2.0 --save 然后执行hexo generate时会自动生成content.json文件，若使用默认设置，生成的数据结构如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445meta: &#123; title: hexo.config.title, subtitle: hexo.config.subtitle, description: hexo.config.description, author: hexo.config.author, url: hexo.config.url&#125;,pages: [&#123; //-&gt; all pages title: page.title, slug: page.slug, date: page.date, updated: page.updated, comments: page.comments, permalink: page.permalink, path: page.path, excerpt: page.excerpt, //-&gt; only text ;) keywords: null //-&gt; it needs settings text: page.content, //-&gt; only text minified ;) raw: page.raw, //-&gt; original MD content content: page.content //-&gt; final HTML content&#125;],posts: [&#123; //-&gt; only published posts title: post.title, slug: post.slug, date: post.date, updated: post.updated, comments: post.comments, permalink: post.permalink, path: post.path, excerpt: post.excerpt, //-&gt; only text ;) keywords: null //-&gt; it needs settings text: post.content, //-&gt; only text minified ;) raw: post.raw, //-&gt; original MD content content: post.content, //-&gt; final HTML content categories: [&#123; name: category.name, slug: category.slug, permalink: category.permalink &#125;], tags: [&#123; name: tag.name, slug: tag.slug, permalink: tag.permalink &#125;]&#125;] 2.配置hexo-generator-json-content默认生成的json数据内容非常全，默认配置如下： 123456789101112131415161718192021222324252627282930313233jsonContent: meta: true keywords: false # (english, spanish, polish, german, french, italian, dutch, russian, portuguese, swedish) pages: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: true # but only if root keywords option language was set text: true raw: false content: false posts: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: true # but only if root keywords option language was set text: true raw: false content: false categories: true tags: true 因为默认生成了很多我们不需要的数据，所以我们要对其进行配置让它只生成我们想要的内容,在hexo/_config.yml中加入： 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true #文章标题 date: true #发表日期 path: true #路径 text: true #文本字段 raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true #标签 这样，就只生成每篇文章的标题，日期，路径，标签和文本字段，同时也减小了文件的大小。例如： 1234567891011&#123; \"title\": \"自定义HEXO站内搜索Javascript+json\", \"date\": \"2016-11-09T01:24:56.000Z\", \"path\": \"2016/11/09/自定义HEXO站内搜索Javascript-json.html\", \"text\": \"目前很多Hexo博客都用的Swiftype和Algolia等第三......#这里显示整篇文章的内容\", \"tags\": [&#123; \"name\": \"javascript,hexo\", \"slug\": \"javascript-hexo\", \"permalink\": \"http://chaoo.oschina.io/tags/javascript-hexo/\" &#125;]&#125; 3.JavaScript实现代码接下来就是用JS实现查询方法并把结果渲染到页面。 3.1 xhr加载数据12345678910111213141516171819202122var searchData;function loadData(success) &#123; if (!searchData) &#123; var xhr = new XMLHttpRequest(); xhr.open('GET', '/content.json', true); xhr.onload = function() &#123; if (this.status &gt;= 200 &amp;&amp; this.status &lt; 300) &#123; var res = JSON.parse(this.response || this.responseText); searchData = res instanceof Array ? res : res.posts; success(searchData); &#125; else &#123; console.error(this.statusText); &#125; &#125;; xhr.onerror = function() &#123; console.error(this.statusText); &#125;; xhr.send(); &#125; else &#123; success(searchData); &#125;&#125; 3.2 匹配文章内容返回结果12345678910function matcher(post, regExp) &#123; // 匹配优先级：title &gt; tags &gt; text return regtest(post.title, regExp) || post.tags.some(function(tag) &#123; return regtest(tag.name, regExp); &#125;) || regtest(post.text, regExp);&#125;function regtest(raw, regExp) &#123; regExp.lastIndex = 0; return regExp.test(raw);&#125; 3.3 结果渲染到页面123456789101112131415function render(data) &#123; var html = ''; if (data.length) &#123; html = data.map(function(post) &#123; return tpl(searchTpl, &#123; title: post.title, path: post.path, date: new Date(post.date).toLocaleDateString(), tags: post.tags.map(function(tag) &#123; return '&lt;span&gt;' + tag.name + '&lt;/span&gt;'; &#125;).join('') &#125;); &#125;).join(''); &#125; &#125; 3.3 查询匹配1234567891011function search(key) &#123; // 关键字 =&gt; 正则，空格隔开的看作多个关键字 // a b c =&gt; /a|b|c/gmi var regExp = new RegExp(key.replace(/[ ]/g, '|'), 'gmi'); loadData(function(data) &#123; var result = data.filter(function(post) &#123; return matcher(post, regExp); &#125;); render(result); &#125;);&#125;","categories":[{"name":"网页技术","slug":"网页技术","permalink":"https://ycg31.oschina.io/categories/网页技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ycg31.oschina.io/tags/hexo/"}]},{"title":"（转）介绍如何为 hexo 写一个本地的搜索引擎","slug":"介绍如何为-hexo-写一个本地的搜索引擎","date":"2017-08-29T16:43:47.000Z","updated":"2017-08-29T16:45:35.017Z","comments":true,"path":"2017/08/30/介绍如何为-hexo-写一个本地的搜索引擎/","link":"","permalink":"https://ycg31.oschina.io/2017/08/30/介绍如何为-hexo-写一个本地的搜索引擎/","excerpt":"","text":"早在我最初从 Ruhoh 迁移博客到 Hexo 时，我就有动手写一个本地的搜索引擎的想法。比起使用第三方服务的站内搜索，本地搜索引擎有几个好处： 更可靠。不用担心由于某些显而易见的原因导致第三方服务不可访问。 速度更快。不管是 Google 还是 Swiftype ，第三方搜索服务的加载速度总是比较慢，影响浏览体验。 定制性更强。由于是自己写的插件，检索的具体策略、界面样式都可以自己定义，满足极客们 Bigger than Bigger 的需求。 这个想法起初是受了 Christian Fei 的 Simple Jekyll Search 启发。在了解了它的原理后，我认为在 Hexo 上实现一个本地搜索引擎并不复杂。大致的思路是： 写一个 generator ，生成站点所有文章的索引数据； 当在搜索框中输入关键词时，触发 Javascript 的特定函数，在这个索引数据里头检索包含该关键词的文章； 利用 jQuery 在页面中动态插入检索结果。 想法对头，就开始动手撸吧。我和一个朋友 maoshuhao 一起合作完成了 hexo-generator-search 插件，用来生成站点的索引数据。有了它，后面的搜索引擎就非常容易实现了。 你可以访问这个 404页面 试试这个本地搜索引擎的效果。如你所见，这个搜索引擎还是一个 live search engine ，即一旦检测到搜索框有修改，就会立即触发检索 1 1对于文章太多的站点，如果认为 live search 影响性能，可以改为回车触发搜索。。 下面介绍如何给自己的博客搭建这样的一个搜索引擎。 最新版本的 hexo-theme-freemind 已提供了本地搜索功能。如果懒得折腾，欢迎使用这个主题。 安装和配置 hexo-generator-search1$ npm install --save hexo-generator-search 然后，在站点根 _config.yml 里头添加设置项： 123search: path: search.xml field: post 其中： path - 指定生成的索引数据的文件名。默认为 search.xml 。 field - 指定索引数据的生成范围。可选值包括： post - 只生成博客文章（post）的索引（默认）； page - 只生成其他页面（page）的索引； all - 生成所有文章和页面的索引。 完成后，可以试试访问预览站点的 search.xml 页面。例如，如果你的预览站点域名是 http://0.0.0.0:4000 ，那么可以访问 http://0.0.0.0:4000/search.xml 看看是否会打开一个 xml 页面。 编写搜索界面搜索界面由一个输入框（input）和一个用于动态插入搜索结果的 div 组成。例如： 1234&lt;div id=\"site_search\"&gt; &lt;input type=\"text\" id=\"local-search-input\" name=\"q\" results=\"0\" placeholder=\"search my blog...\" class=\"form-control\"/&gt; &lt;div id=\"local-search-result\"&gt;&lt;/div&gt;&lt;/div&gt; 你也可以根据自己的喜好写成其他的形式，例如把用于插入结果的 div 移动到页面的其他地方。 实现本地搜索函数接下来编写一个 search.js 脚本，用来实现基于 search.xml 的本地检索函数 searchFunc ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293var searchFunc = function(path, search_id, content_id) &#123; 'use strict'; $.ajax(&#123; url: path, dataType: \"xml\", success: function( xmlResponse ) &#123; // get the contents from search data var datas = $( \"entry\", xmlResponse ).map(function() &#123; return &#123; title: $( \"title\", this ).text(), content: $(\"content\",this).text(), url: $( \"url\" , this).text() &#125;; &#125;).get(); var $input = document.getElementById(search_id); var $resultContent = document.getElementById(content_id); $input.addEventListener('input', function()&#123; var str='&lt;ul class=\\\"search-result-list\\\"&gt;'; var keywords = this.value.trim().toLowerCase().split(/[\\s\\-]+/); $resultContent.innerHTML = \"\"; if (this.value.trim().length &lt;= 0) &#123; return; &#125; // perform local searching datas.forEach(function(data) &#123; var isMatch = true; var content_index = []; var data_title = data.title.trim().toLowerCase(); var data_content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g,\"\").toLowerCase(); var data_url = data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty titles and contents if(data_title != '' &amp;&amp; data_content != '') &#123; keywords.forEach(function(keyword, i) &#123; index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if( index_title &lt; 0 &amp;&amp; index_content &lt; 0 )&#123; isMatch = false; &#125; else &#123; if (index_content &lt; 0) &#123; index_content = 0; &#125; if (i == 0) &#123; first_occur = index_content; &#125; &#125; &#125;); &#125; // show search results if (isMatch) &#123; str += \"&lt;li&gt;&lt;a href='\"+ data_url +\"' class='search-result-title'&gt;\"+ data_title +\"&lt;/a&gt;\"; var content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g,\"\"); if (first_occur &gt;= 0) &#123; // cut out 100 characters var start = first_occur - 20; var end = first_occur + 80; if(start &lt; 0)&#123; start = 0; &#125; if(start == 0)&#123; end = 100; &#125; if(end &gt; content.length)&#123; end = content.length; &#125; var match_content = content.substr(start, end); // highlight all keywords keywords.forEach(function(keyword)&#123; var regS = new RegExp(keyword, \"gi\"); match_content = match_content.replace(regS, \"&lt;em class=\\\"search-keyword\\\"&gt;\"+keyword+\"&lt;/em&gt;\"); &#125;); str += \"&lt;p class=\\\"search-result\\\"&gt;\" + match_content +\"...&lt;/p&gt;\" &#125; str += \"&lt;/li&gt;\"; &#125; &#125;); str += \"&lt;/ul&gt;\"; $resultContent.innerHTML = str; &#125;); &#125; &#125;);&#125; searchFunc 包含三个参数： path - 用 hexo-generator-search 生成的搜索索引文件的路径。注意这个 path 和前面 hexo-generator-search 的 path 选项有所不同。这里的 path 才是指这个文件的路径，而前面的 path 指的是生成的文件名 2 2也许第二个 path 叫 filename 更合适。； search_id - 搜索框的 id 。对于我们的例子，就是 local-search-input; content_id - 结果框的 id 。对于我们的例子，就是 local-search-result。 调用搜索函数有了上面的检索函数，接下来可以在适当时机调用它。由于 path 的实际地址是根 _config.yml 里 config.root+ config.search.path 两个值组成，所以我们最好将这个调用写在页面模板中，以方便获取站点的设置信息。例如，对于 ejs 模板： 12345678&lt;script type=\"text/javascript\"&gt; var search_path = \"&lt;%= config.search.path %&gt;\"; if (search_path.length == 0) &#123; search_path = \"search.xml\"; &#125; var path = \"&lt;%= config.root %&gt;\" + search_path; searchFunc(path, 'local-search-input', 'local-search-result');&lt;/script&gt; 至此就完成了本地检索引擎的实线，最后的工作就是修改样式，让检索页面更美观。在 searchFunc 函数中，我已经为几个关键的页面元素设定了 css 名： ul.search-result-list - 搜索结果列表的样式名； a.search-result-title - 搜索结果文章标题的样式名； p.search-result - 搜索结果每篇文章的预览段落的样式名； em.search-keyword - 搜索结果每篇文章的预览段落中匹配关键词的样式名。 最后给出 hexo-theme-freemind 主题的相关样式： 12345678910111213141516ul.search-result-list &#123; padding-left: 10px;&#125;a.search-result-title &#123; font-weight: bold;&#125;p.search-result &#123; color=#555;&#125;em.search-keyword &#123; border-bottom: 1px dashed #4088b8; font-weight: bold;&#125;","categories":[{"name":"网页技术","slug":"网页技术","permalink":"https://ycg31.oschina.io/categories/网页技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ycg31.oschina.io/tags/hexo/"}]},{"title":"（写一个自己的HEXO主题","slug":"写一个自己的HEXO主题","date":"2017-08-29T16:41:24.000Z","updated":"2017-08-29T16:42:40.804Z","comments":true,"path":"2017/08/30/写一个自己的HEXO主题/","link":"","permalink":"https://ycg31.oschina.io/2017/08/30/写一个自己的HEXO主题/","excerpt":"","text":"最开始折腾Hexo的时候感觉这东西很神奇，通过他和github搭配就能生成免费的静态博客，而且还有丰富的主题可以选择，当我刚入Hexo的时候默认主题是landscape，后来又使用过NexT，是一款很漂亮的主题，但是除此之外，还有很多好看的主题，我很好奇这些主题都是怎么写出来的，于是乎就仿照landscape主题开始研究，写自己的主题，也就是我自己的博客正在用的主题，项目地址在这里。 完成一个Hexo的主题其实很简单，和写静态页面差不多，只是内容部分通过Hexo的变量去获取，而且Hexo还内置了一些辅助函数帮你快速方便地完成繁琐的处理。 起步在写代码之前要先把项目结构搭建好，一个Hexo主题的项目名就是主题名字本身，项目内的目录结构如下: (生成树形图是用的tree， mac上直接brew install tree就可以了，以前不写都不知道囧) 123456789.├── _config.yml //记录主题配置信息├── layout //存放布局模板文件│ └── _partial //布局文件中可共用的模板└── source //静态资源文件夹 ├── css ├── fonts ├── js └── sass 项目结构搞好就可以开始写代码了!因为当初我是仿landscape写的，而且ejs也是我之前看nodejs时就接触过的，因此就直接用ejs写模板文件了，样式使用了sass (scss。 布局编写布局文件(layout.ejs)模板文件在layout文件夹下，文件名对应Hexo中的模板名，有index,post,page,archive,category,tag几种，对于普通的header + content + footer的页面结构，header和footer往往是可以复用的，因此我们可以使用layout.ejs进行布局，动态的内容使用body变量去动态渲染，所以我的layout.ejs大概长这样: 1234567891011121314151617&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\"/&gt; &lt;title&gt;&lt;%= config.title %&gt;&lt;/title&gt; &lt;%- css('css/style') %&gt;&lt;/head&gt;&lt;body&gt; &lt;%- partial('_partial/header') %&gt; &lt;div class=\"main\"&gt; &lt;%- body %&gt; &lt;/div&gt; &lt;%- partial('_partial/footer') %&gt; &lt;%- js('js/index.js') %&gt;&lt;/body&gt;&lt;/html&gt; partial,js和css是Hexo提供的辅助函数，后面再说。 其他模板文件每一个模板文件对应的是一种布局，当你使用hexo new &lt;title&gt;的时候，其实忽略了一个参数，完整的命令是hexo new [layout] &lt;title&gt;，这个layout就决定了文章使用何种方式布局，比如创建一个自己简介的About页面，hexo new page &quot;about&quot;其实就是使用了page布局。每种布局对应到我们的模板文件上就是index.ejs(首页),post.ejs(文章),archive.ejs(归档),tag.ejs(标签归档),page.ejs(分页)。 如果更直观一点，url和模板的对应关系是这样的: Url Description Layout / 首页 index.ejs /yyyy/mm/dd/:title/ 文章 post.ejs /archives/ 归档 archive.ejs /tags/:tagname/ 某个标签的归档 tag.ejs /:else/ 其他 page.ejs index.ejs首页一般是一些博文的摘要和一个分页器，通过Hexo的page变量拿到页面的数据渲染即可，这里我们不直接在index.ejs中写HTML结构，新建一个_partial/article.ejs，将文章数据传给子模板渲染，然后再额外传入一个参数{index: true}，对后面的post.ejs和page.ejs加以区分，让子模板能正确渲染。最后，index.ejs大致是这样的: 1234567//index.ejs&lt;% page.posts.each(function(post, index)&#123; %&gt; &lt;%- partial('_partial/article', &#123;index: true, post: post&#125;) %&gt;&lt;% &#125;) %&gt;&lt;div class=\"pagination\"&gt; &lt;%- paginator(&#123; total: Math.ceil(site.posts.length / config.per_page)&#125;) %&gt;&lt;/div&gt; post.ejs文章模板和首页差不多，只是对应的是一篇具体的文章，所以就把文章传入，再额外传入{index: false}告诉子模板不要按首页的方式去渲染就好了。就一行代码(因为都在子模板里 XD 12//post.ejs&lt;%- partial('_partial/article', &#123;index: false, post: page&#125;) %&gt; page.ejs我个人对Page模板其实是有点懵逼的，在我自己的实践中是添加about(hexo new page &quot;about&quot;)页面后，访问/about会走分页布局，实际上这个页面对应的内容是/source/about里的index.md，也相当于对文章的渲染，因此我把Page模板也写成了和文章模板一样: 12//page.ejs&lt;%- partial('_partial/article', &#123;index: false, post: page&#125;) %&gt; _partial/article.ejs前面一共有三处共用了article模板，另外page和post的一样的，所以实际上只有两种情况:主页(index: true)和非主页(index: false)。对应的_partial/article.ejs里只要判断这个值就可以正确渲染了，基本结构如下： 123456//_partial/article.ejs&lt;% if(index)&#123; %&gt; //index logic...&lt;% &#125;else&#123; %&gt; //post or page logic...&lt;% &#125; %&gt; tag.ejs标签归档页内容很少，直接用Hexo的辅助函数list_tags生成一个标签的列表就ok了:之前对tag模板的理解错误了，tag.ejs作用的是具体tag下的归档布局，因此和archive.ejs差不多: 12345678910//tag.ejs&lt;div class=\"tags\"&gt; &lt;h1&gt;&lt;%= page.tag %&gt;&lt;/h1&gt; &lt;% page.posts.each(function(post)&#123; %&gt; &lt;div class=\"tag_item\"&gt; &lt;a class=\"title\" href=\"&lt;%- url_for(post.path) %&gt;\"&gt;&lt;%= post.title %&gt;&lt;/a&gt; &lt;span class=\"date\"&gt;&lt;%= post.date.format('YYYY-MM-DD') %&gt;&lt;/span&gt; &lt;/div&gt; &lt;% &#125;) %&gt;&lt;/div&gt; 归档页模板和首页差不多，归档页只需要展示文章标题和最后的分页器就好: 123456789101112131415161718//archive.ejs&lt;div class=\"archive\"&gt; &lt;% var lastyear; %&gt; &lt;% page.posts.each(function(post)&#123; %&gt; &lt;% var year = post.date.year() %&gt; &lt;% if(lastyear !== year)&#123; %&gt; &lt;h4 class=\"year\"&gt;&lt;%= year %&gt;&lt;/h4&gt; &lt;% lastyear = year %&gt; &lt;% &#125; %&gt; &lt;div class=\"archive_item\"&gt; &lt;a class=\"title\" href=\"&lt;%- url_for(post.path) %&gt;\"&gt;&lt;%= post.title %&gt;&lt;/a&gt; &lt;span class=\"date\"&gt;&lt;%= post.date.format('YYYY-MM-DD') %&gt;&lt;/span&gt; &lt;/div&gt; &lt;% &#125;) %&gt; &lt;div class=\"pagination\"&gt; &lt;%- paginator(&#123; total: Math.ceil(site.posts.length / config.per_page)&#125;) %&gt; &lt;/div&gt;&lt;/div&gt; 至此，模板文件就写好了，对于category模板就放弃了，感觉比较鸡肋。。。 变量其实在模板文件中我们已经看到了page.post,site.posts.length,config.per_page等等，页面的内容就是根据这些变量获取的，由Hexo提供，拿来直接用，Hexo提供了很多变量，但不是都很常用，一般就用到以下变量: site: 对应整个网站的变量，一般会用到site.posts.length制作分页器 page: 对应当前页面的信息，例如我在index.ejs中使用page.posts获取了当前页面的所有文章而不是使用site.posts。 config: 博客的配置信息，博客根目录下的_config.yml。 theme: 主题的配置信息，对于主题根目录下的_config.yml。 辅助函数(Helper)制作一个分页器，我们需要知道文章的总数和每页展示的文章数，然后通过循环生成每个link标签，还要根据当前页面判断link标签的active状态，但是在Hexo中这些都不用我们自己来做了!Hexo提供了paginator这一辅助函数帮助我们生成分页器，只需要将文章总数site.posts.length和每页文章数config.per_page传入就可以生成了。 其他的Helper: list_tags([options]): 快速生成标签列表 js(path/to/js), css(path/to/css) 用来载入静态资源，path可以是字符串或数组(载入多个资源)，默认会去source文件夹下去找。 partial(path/to/partial) 引用字模板，默认会去layout文件夹下找。 样式知道了Hexo的渲染方式，我们就可以使用HTML标签+CSS样式个性化我们的主题了，推荐大家使用CSS预处理语言的一种来写样式，这样就可以通过预处理语言自身的特点让样式更灵活。 其他添加对多说和Disqus的支持评论是很常用的功能，不如就直接在我们的主题里支持了，然后通过配置变量决定是否开启，评论区跟在文章内容下面，对于这种三方的代码块，最好也以partial的方式提取出来，方便移除或是替换。 123456789101112131415//_partial/article.ejs&lt;section class='post-content'&gt; &lt;%- post.content %&gt;&lt;/section&gt;//评论部分，post.comments判断是否开启评论，config.duoshuo_shortname和config.disqus_shortname来判断启用那种评论插件，这里优先判断了多说&lt;% if(post.comments)&#123; %&gt; &lt;section id=\"comments\"&gt; &lt;% if (config.duoshuo_shortname)&#123; %&gt; &lt;%- partial('_partial/duoshuo') %&gt; &lt;% &#125;else if(config.disqus_shortname)&#123; %&gt; &lt;%- partial('_partial/disqus') %&gt; &lt;% &#125; %&gt; &lt;/section&gt;&lt;% &#125; %&gt; 再将多说和Disqus提供的js脚本代码放在_partial/duoshuo.ejs和_partial/disqus.ejs下就ok了~ 使用highlight.js提供代码高亮highlight.js提供了多种语言的支持和多种皮肤，用法也很简单，载入文件后调用初始化方法，一切都帮你搞定，对于使用那种皮肤，喜好因人而异，我们干脆在主题的配置文件中做成配置项让用户自己选择: 123456//showonne/_config.yml...other configs# highlight.jshighlight_theme: zenburn 对应的layout.ejs中: 1&lt;link rel=\"stylesheet\" href=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/styles/&lt;%= theme.highlight_theme %&gt;.min.css\"&gt; 样式文件通过CDN引入，因为不同皮肤对应不同的文件名，所以十分灵活。 最后当初是对应着landscape照葫芦画瓢写的，最近回头来发现一些不合理的地方，所以就又改了改，也对应着写了这么一篇总结，接下来准备再把样式划分一下，对于颜色这类样式通过变量的方式提取出来，也变得可配置，能让主题更灵活一些。 参考资源了解辅助函数模板Hexo中的变量Hexo主题列表Hexo使用多说教程How to use highlight.js","categories":[{"name":"网页技术","slug":"网页技术","permalink":"https://ycg31.oschina.io/categories/网页技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ycg31.oschina.io/tags/hexo/"},{"name":"theme","slug":"theme","permalink":"https://ycg31.oschina.io/tags/theme/"}]},{"title":"jQuery选择器总结","slug":"jQuery选择器总结","date":"2017-08-29T16:35:18.000Z","updated":"2017-08-29T16:39:27.394Z","comments":true,"path":"2017/08/30/jQuery选择器总结/","link":"","permalink":"https://ycg31.oschina.io/2017/08/30/jQuery选择器总结/","excerpt":"","text":"jQuery 的选择器可谓之强大无比，这里简单地总结一下常用的元素查找方法 各种选择方式$(“#myELement”) 选择id值等于myElement的元素，id值不能重复在文档中只能有一个id值是myElement所以得到的是唯一的元素$(“div”) 选择所有的div标签元素，返回div元素数组$(“.myClass”) 选择使用myClass类的css的所有元素$(“*”) 选择文档中的所有的元素，可以运用多种的选择方式进行联合选择：例如$(“#myELement,div,.myclass”) 层叠选择器：$(“form input”) 选择所有的form元素中的input元素$(“#main &gt; *”) 选择id值为main的所有的子元素$(“label + input”) 选择所有的label元素的下一个input元素节点，经测试选择器返回的是label标签后面直接跟一个input标签的所有input标签元素$(“#prev ~ div”) 同胞选择器，该选择器返回的为id为prev的标签元素的所有的属于同一个父元素的div标签 基本过滤选择器：$(“tr:first”) 选择所有tr元素的第一个$(“tr:last”) 选择所有tr元素的最后一个$(“input:not(:checked) + span”) 过滤掉：checked的选择器的所有的input元素 $(“tr:even”) 选择所有的tr元素的第0，2，4… …个元素（注意：因为所选择的多个元素时为数组，所以序号是从0开始） $(“tr:odd”) 选择所有的tr元素的第1，3，5… …个元素$(“td:eq(2)”) 选择所有的td元素中序号为2的那个td元素$(“td:gt(4)”) 选择td元素中序号大于4的所有td元素$(“td:ll(4)”) 选择td元素中序号小于4的所有的td元素$(“:header”)$(“div:animated”) 内容过滤选择器：$(“div:contains(‘John’)”) 选择所有div中含有John文本的元素$(“td:empty”) 选择所有的为空（也不包括文本节点）的td元素的数组$(“div:has(p)”) 选择所有含有p标签的div元素$(“td:parent”) 选择所有的以td为父节点的元素数组可视化过滤选择器： $(“div:hidden”) 选择所有的被hidden的div元素$(“div:visible”) 选择所有的可视化的div元素 属性过滤选择器：$(“div[id]”) 选择所有含有id属性的div元素$(“input[name=’newsletter’]”) 选择所有的name属性等于’newsletter’的input元素 $(“input[name!=’newsletter’]”) 选择所有的name属性不等于’newsletter’的input元素 $(“input[name^=’news’]”) 选择所有的name属性以’news’开头的input元素$(“input[name$=’news’]”) 选择所有的name属性以’news’结尾的input元素$(“input[name*=’man’]”) 选择所有的name属性包含’news’的input元素 $(“input[id][name$=’man’]”) 可以使用多个属性进行联合选择，该选择器是得到所有的含有id属性并且那么属性以man结尾的元素 子元素过滤选择器：$(“ul li:nth-child(2)”),$(“ul li:nth-child(odd)”),$(“ul li:nth-child(3n + 1)”) $(“div span:first-child”) 返回所有的div元素的第一个子节点的数组$(“div span:last-child”) 返回所有的div元素的最后一个节点的数组$(“div button:only-child”) 返回所有的div中只有唯一一个子节点的所有子节点的数组 表单元素选择器：$(“:input”) 选择所有的表单输入元素，包括input, textarea, select 和 button$(“:text”) 选择所有的text input元素$(“:password”) 选择所有的password input元素$(“:radio”) 选择所有的radio input元素$(“:checkbox”) 选择所有的checkbox input元素$(“:submit”) 选择所有的submit input元素$(“:image”) 选择所有的image input元素$(“:reset”) 选择所有的reset input元素$(“:button”) 选择所有的button input元素$(“:file”) 选择所有的file input元素$(“:hidden”) 选择所有类型为hidden的input元素或表单的隐藏域 表单元素过滤选择器：$(“:enabled”) 选择所有的可操作的表单元素$(“:disabled”) 选择所有的不可操作的表单元素$(“:checked”) 选择所有的被checked的表单元素$(“select option:selected”) 选择所有的select 的子元素中被selected的元素 选取一个 name 为”S_03_22″的input text框的上一个td的text值$(”input[@ name =S_03_22]“).parent().prev().text() 名字以”S_”开始，并且不是以”R”结尾的$(”input[@ name ^=’S‘]“).not(”[@ name $=’_R’]“) 一个名为 radio_01的radio所选的值$(”input[@ name =radio_01][@checked]“).val(); $(“A B”) 查找A元素下面的所有子节点，包括非直接子节点$(“A&gt;B”) 查找A元素下面的直接子节点$(“A+B”) 查找A元素后面的兄弟节点，包括非直接子节点$(“A~B”) 查找A元素后面的兄弟节点，不包括非直接子节点 $(“A B”) 查找A元素下面的所有子节点，包括非直接子节点 例子：找到表单中所有的 input 元素 HTML 代码: Name: Newsletter: jQuery 代码: $(“form input”)结果: [ , ] $(“A&gt;B”) 查找A元素下面的直接子节点例子：匹配表单中所有的子级input元素。 HTML 代码: Name: Newsletter: jQuery 代码: $(“form &gt; input”)结果: [ ] $(“A+B”) 查找A元素后面的兄弟节点，包括非直接子节点例子：匹配所有跟在 label 后面的 input 元素 HTML 代码: Name: Newsletter: jQuery 代码: $(“label + input”)结果: [ , ] $(“A~B”) 查找A元素后面的兄弟节点，不包括非直接子节点例子：找到所有与表单同辈的 input 元素 HTML 代码: Name: Newsletter: jQuery 代码: $(“form ~ input”)结果: [ ]","categories":[{"name":"网络技术","slug":"网络技术","permalink":"https://ycg31.oschina.io/categories/网络技术/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://ycg31.oschina.io/tags/jQuery/"}]},{"title":"Flex 布局教程：语法篇","slug":"Flex-布局教程：语法篇","date":"2017-08-28T04:36:56.000Z","updated":"2017-08-29T17:39:25.583Z","comments":true,"path":"2017/08/28/Flex-布局教程：语法篇/","link":"","permalink":"https://ycg31.oschina.io/2017/08/28/Flex-布局教程：语法篇/","excerpt":"","text":"网页布局（layout）是 CSS 的一个重点应用。 布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex 布局将成为未来布局的首选方案。本文介绍它的语法，下一篇文章给出常见布局的 Flex 写法。网友 JailBreak 为本文的所有示例制作了 Demo，也可以参考。 以下内容主要参考了下面两篇文章：A Complete Guide to Flexbox 和 A Visual Guide to CSS3 Flexbox Properties。 一、Flex 布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 12345&gt; .box&#123;&gt; display: flex;&gt; &#125;&gt;&gt; 行内元素也可以使用 Flex 布局。 12345&gt; .box&#123;&gt; display: inline-flex;&gt; &#125;&gt;&gt; Webkit 内核的浏览器，必须加上-webkit前缀。 123456&gt; .box&#123;&gt; display: -webkit-flex; /* Safari */&gt; display: flex;&gt; &#125;&gt;&gt; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 12345&gt; .box &#123;&gt; flex-direction: row | row-reverse | column | column-reverse;&gt; &#125;&gt;&gt; 它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 12345&gt; .box&#123;&gt; flex-wrap: nowrap | wrap | wrap-reverse;&gt; &#125;&gt;&gt; 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 12345&gt; .box &#123;&gt; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&gt; &#125;&gt;&gt; 3.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 12345&gt; .box &#123;&gt; justify-content: flex-start | flex-end | center | space-between | space-around;&gt; &#125;&gt;&gt; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性align-items属性定义项目在交叉轴上如何对齐。 12345&gt; .box &#123;&gt; align-items: flex-start | flex-end | center | baseline | stretch;&gt; &#125;&gt;&gt; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 12345&gt; .box &#123;&gt; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&gt; &#125;&gt;&gt; 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 12345&gt; .item &#123;&gt; order: &lt;integer&gt;;&gt; &#125;&gt;&gt; 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 12345&gt; .item &#123;&gt; flex-grow: &lt;number&gt;; /* default 0 */&gt; &#125;&gt;&gt; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 12345&gt; .item &#123;&gt; flex-shrink: &lt;number&gt;; /* default 1 */&gt; &#125;&gt;&gt; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 12345&gt; .item &#123;&gt; flex-basis: &lt;length&gt; | auto; /* default auto */&gt; &#125;&gt;&gt; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 12345&gt; .item &#123;&gt; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&gt; &#125;&gt;&gt; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 12345&gt; .item &#123;&gt; align-self: auto | flex-start | flex-end | center | baseline | stretch;&gt; &#125;&gt;&gt; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。","categories":[{"name":"网页技术","slug":"网页技术","permalink":"https://ycg31.oschina.io/categories/网页技术/"}],"tags":[{"name":"css","slug":"css","permalink":"https://ycg31.oschina.io/tags/css/"},{"name":"flex","slug":"flex","permalink":"https://ycg31.oschina.io/tags/flex/"}]},{"title":"CSS padding margin border属性详解","slug":"CSS padding margin border属性详解","date":"2017-08-25T04:36:56.000Z","updated":"2017-08-29T17:39:24.109Z","comments":true,"path":"2017/08/25/CSS padding margin border属性详解/","link":"","permalink":"https://ycg31.oschina.io/2017/08/25/CSS padding margin border属性详解/","excerpt":"","text":"图解CSS padding、margin、border属性W3C组织建议把所有网页上的对像都放在一个盒(box)中，设计师可以通过创建定义来控制这个盒的属性，这些对像包括段落、列表、标题、图片以及层。盒模型主要定义四个区域：内容(content)、内边距(padding)、边框(border)和外边距(margin)。对于初学者，经常会搞不清楚margin，background-color，background-image，padding，content，border之间的层次、关系和相互影响。这里提供一张盒模型的3D示意图，希望便于你的理解和记忆。 123456margin：层的边框以外留的空白background-color：背景颜色background-image：背景图片padding：层的边框到层的内容之间的空白 border：边框 content：内容 接下来将讲述HTML和CSS的关键——盒子模型(Box model)。理解Box model的关键便是margin和padding属性，而正确理解这两个属性也是学习用css布局的关键。 注: 为什么不翻译margin和padding?原因一: 在汉语中并没有与之相对应的词语；原因二: 即使有这样的词语, 由于在编写css代码时, 必须使用margin和padding, 如果我们总用汉语词语代替其来解释的话, 到了实际应用时容易混淆margin和padding的概念。 如果有一点Html基础的话，就应该了解一些基本元素(Element)，如p、h1~h6、br、div、li、ul、img等。如果将这些元素细分，又可以分别为顶级(top-level)元素、块级(block-level)元素和内联(inline)元素。 块级元素是构成一个html的主要和关键元素，而任意一个块级元素均可以用Box model来解释说明。Box Model: 任意一个块级元素均由content(内容)、padding、background(包括背景颜色和图片)、border(边框)、margin五个部分组成。立体图如下: 平面图如下: 根据以上两图，相信大家对于Box model会有个直观的认识。 以下说明margin和padding属性:1、margin: 包括margin-top、margin-right、margin-bottom、margin-left，控制块级元素之间的距离，它们是透明不可见的。根据上、 右、下、左的顺时针规则，可以写为 margin: 40px 40px 40px 40px;为便于记忆，请参考下图: 当上下、左右margin值分别一致, 可简写为: 1margin: 40px 40px; 前一个40px代表上下margin值，后一个40px代表左右margin值。当上下左右margin值均一致，可简写为: 1margin: 40px; 2、Padding: 包括padding-top、padding-right、padding-bottom、padding-left，控制块级元素内部，content与border之间的距离，其代码，简写请参考margin属性的写法。 至此，我们已经基本了解margin和padding属性的基本用法。但是，在实际应用中，却总是发生一些让你琢磨不透的事，而它们又或多或少的与margin有关。 注: 当你想让两个元素的content在垂直方向(vertically)分隔时，既可以选择padding-top/bottom，也可以选择margin-top/bottom，再此Ruthless建议你尽量使用padding-top/bottom来达到你的目的，这是因为css中存在Collapsing margins(折叠的margins)的现象。 Collapsing margins: margins折叠现象只存在于临近或有从属关系的元素，垂直方向的margin中。 详细说明如下：如果只提供一个，将用于全部的四条边；如果提供两个，第一个用于上－下，第二个用于左－右；如果提供三个，第一个用于上，第二个用于左－右，第三个用于下；如果提供全部四个参数值，将按上－右－下－左的顺序作用于四边。 1234body &#123; padding: 36px;&#125; //对象四边的补丁边距均为36px body &#123; padding: 36px 24px; &#125; //上下两边的补丁边距为36px，左右两边的补丁边距为24px body &#123; padding: 36px 24px 18px; &#125; //上、下两边的补丁边距分别为36px、18px，左右两边的补丁边距为24px body &#123; padding: 36px 24px 18px 12px; &#125; //上、右、下、左补丁边距分别为36px、24px、18px、12px","categories":[{"name":"网页技术","slug":"网页技术","permalink":"https://ycg31.oschina.io/categories/网页技术/"}],"tags":[{"name":"css","slug":"css","permalink":"https://ycg31.oschina.io/tags/css/"}]},{"title":"CSS中position属性( absolute | relative | static | fixed )详解","slug":"CSS中position属性-absolute-relative-static-fixed-详解","date":"2017-08-25T04:17:01.000Z","updated":"2017-08-29T17:39:25.325Z","comments":true,"path":"2017/08/25/CSS中position属性-absolute-relative-static-fixed-详解/","link":"","permalink":"https://ycg31.oschina.io/2017/08/25/CSS中position属性-absolute-relative-static-fixed-详解/","excerpt":"","text":"我们先来看看CSS3 Api中对position属性的相关定义： static：无特殊定位，对象遵循正常文档流。top，right，bottom，left等属性不会被应用。 relative：对象遵循正常文档流，但将依据top，right，bottom，left等属性在正常文档流中偏移位置。而其层叠通过z-index属性定义。 absolute：对象脱离正常文档流，使用top，right，bottom，left等属性进行绝对定位。而其层叠通过z-index属性定义。 fixed：对象脱离正常文档流，使用top，right，bottom，left等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动。而其层叠通过z-index属性定义。 怎么样，是不是还是很迷糊~~ 没关系，下面就从几个基础概念一一给大家详述： 什么是文档流？ ​ 将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素,即为文档流。 ​ 只有三种情况会使得元素脱离文档流，分别是：浮动、绝对定位和相对定位。 静态定位(static) ： ​ static，无特殊定位，它是html元素默认的定位方式，即我们不设定元素的position属性时默认的position值就是static，它遵循正常的文档流对象，对象占用文档空间，该定位方式下，top、right、bottom、left、z-index等属性是无效的。 相对定位(relative) ： ​ relative定位，又称为相对定位，从字面上来解析，我们就可以看出该属性的主要特性：相对。但是它相对的又是相对于什么地方而言的呢？这个是个重点，也是最让我迷糊的一个地方，现在让我们来做个测试，我想大家都会明白的： (1) 初始未定位 123456789/******初始*********/&lt;style type=\"text/css\"&gt; #first &#123; width: 200px; height: 100px; border: 1px solid red; &#125; #second&#123; width: 200px; height: 100px; border: 1px solid blue;&#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"first\"&gt; first&lt;/div&gt; &lt;div id=\"second\"&gt;second&lt;/div&gt;&lt;/body&gt; 初始原图： (2) 我们修改first元素的position属性： 1234&lt;style type=\"text/css\"&gt; #first&#123; width: 200px; height: 100px; border: 1px solid red; position: relative; top: 20px; left: 20px;&#125; /*add position*/ #second&#123;width: 200px; height: 100px; border: 1px solid blue;&#125;&lt;/style&gt; 相对偏移20px后： – &gt;&gt; 虚线是初始的位置空间 ​ 现在看明白了吧，相对定位相对的是它原本在文档流中的位置而进行的偏移，而我们也知道relative定位也是遵循正常的文档流，它没有脱离文档流，但是它的top/left/right/bottom属性是生效的，可以说它是static到absoult的一个中间过渡属性，最重要的是它还占有文档空间，而且占据的文档空间不会随 top / right / left / bottom 等属性的偏移而发生变动，也就是说它后面的元素是依据虚线位置( top / left / right / bottom 等属性生效之前)进行的定位，这点一定要理解。 ​ 那好，我们知道了top / right / left / bottom 属性是不会对relative定位的元素所占据的文档空间产生偏移，那么margin / padding会让该文档空间产生偏移吗？答案是肯定的，我们一起来做个试验吧： (3) 添加margin属性： 1234&lt;style type=\"text/css\"&gt; #first&#123;width: 200px;height: 100px;border: 1px solid red;position: relative;top: 20px;left: 20px;margin: 20px;&#125; /* add margin*/ #second&#123;width: 200px;height:100px;border: 1px solid blue;&#125;&lt;/style&gt; 设置margin：20px后： ​ 对比一下，是不是就很清晰了，我们先将first元素外边距设为20px，那么second元素就得向下偏移40px，所以margin是占据文档空间！同理，大家可以自己动手测下padding的效果吧！ 绝对定位(absoulte) ： ​ absoulte定位，也称为绝对定位，虽然它的名字号曰“绝对”，但是它的功能却更接近于”相对”一词，为什么这么讲呢？原来，使用absoult定位的元素脱离文档流后，就只能根据祖先类元素(父类以上)进行定位，而这个祖先类还必须是以postion非static方式定位的， 举个例子，a元素使用absoulte定位，它会从父类开始找起，寻找以position非static方式定位的祖先类元素(注意，一定要是直系祖先才算哦~），直到标签为止，这里还需要注意的是，relative和static方式在最外层时是以标签为定位原点的，而absoulte方式在无父级是position非static定位时是以作为原点定位。和元素相差9px左右。我们来看下效果： (4) 添加absoulte属性： 123456789101112&lt;html&gt;&lt;style type=\"text/css\"&gt; html&#123;border:1px dashed green;&#125; body&#123;border:1px dashed purple;&#125; #first&#123; width: 200px;height: 100px;border: 1px solid red;position: relative;&#125; #second&#123; width: 200px;height: 100px;border: 1px solid blue;position: absolute;top :0;left : 0;&#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"first\"&gt;relative&lt;/div&gt; &lt;div id=\"second\"&gt;absoult&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图： ​ 哈哈，看了上面的代码后，细心的朋友肯定要问了，为什么absoulte定位要加 top:0; left:0; 属性，这不是多此一举呢？ ​ 其实加上这两个属性是完全必要的，因为我们如果使用absoulte或fixed定位的话，必须指定 left、right、 top、 bottom 属性中的至少一个，否则left/right/top/bottom属性会使用它们的默认值 auto ，这将导致对象遵从正常的HTML布局规则，在前一个对象之后立即被呈递*，*简单讲就是都变成relative，会占用文档空间，这点非常重要，很多人使用absolute定位后发现没有脱离文档流就是这个原因，这里要特别注意~~~ 少了left/right/top/bottom属性不行，那如果我们多设了呢？例如，我们同时设置了top和bottom的属性值，那元素又该往哪偏移好呢？记住下面的规则： 如果top和bottom一同存在的话，那么只有top生效。 如果left和right一同存在的话，那么只有left生效。 既然absoulte是根据祖先类中的position非static元素进行定位的，那么祖先类中的margin/padding会不会对position产生影响呢？看个例子先： (5) 在absoulte定位中添加margin / padding属性： 123456#first&#123;width: 200px;height: 100px;border: 1px solid red;position: relative;margin:40px;padding:40px;&#125;#second&#123;width: 200px;height:100px;border: 1px solid blue;position: absolute;top:20px;left:20px;&#125; &lt;div id=\"first\"&gt;first &lt;div id=\"second\"&gt;second&lt;/div&gt;&lt;/div&gt; 效果图： ​ 看懂了，祖先类的margin会让子类的absoulte跟着偏移，而padding却不会让子类的absoulte发生偏移。总结一下，就是absoulte是根据祖先类的border进行的定位。 Note : 绝对(absolute)定位对象在可视区域之外会导致滚动条出现。而放置相对(relative)定位对象在可视区域之外，滚动条不会出现。 固定定位(fixed)： ​ fixed定位，又称为固定定位，它和absoult定位一样，都脱离了文档流，并且能够根据top、right、left、bottom属性进行定位，但不同的是fixed是根据窗口为原点进行偏移定位的，也就是说它不会根据滚动条的滚动而进行偏移。 z-index属性： ​ z-index，又称为对象的层叠顺序，它用一个整数来定义堆叠的层次，整数值越大，则被层叠在越上面，当然这是指同级元素间的堆叠，如果两个对象的此属性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。需要注意的是，父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。 Note：使用static 定位或无position定位的元素z-index属性是无效的。","categories":[{"name":"网页技术","slug":"网页技术","permalink":"https://ycg31.oschina.io/categories/网页技术/"}],"tags":[{"name":"css","slug":"css","permalink":"https://ycg31.oschina.io/tags/css/"}]},{"title":"Git忽略规则和.gitignore规则不生效的解决办法","slug":"Git忽略规则和-gitignore规则不生效的解决办法","date":"2017-08-20T15:42:24.000Z","updated":"2017-08-20T15:58:32.151Z","comments":true,"path":"2017/08/20/Git忽略规则和-gitignore规则不生效的解决办法/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/Git忽略规则和-gitignore规则不生效的解决办法/","excerpt":"","text":"Git忽略规则：在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如果没有这个文件，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则例如： 以斜杠“/”开头表示目录； 以星号“*”通配多个字符； 以问号“?”通配单个字符 以方括号“[]”包含单个字符的匹配列表； 以叹号“!”表示不忽略(跟踪)匹配到的文件或目录； 12345678910# 此为注释 – 将被 Git 忽略*.sample # 忽略所有 .sample 结尾的文件!lib.sample # 但 lib.sample 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txtfd1/* #忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；/fd1/* #忽略根目录下的 /fd1/ 目录的全部内容；#此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效； 实现的三种方法有三种方法可以实现过滤掉Git里不想上传的文件，这三种方法都能达到目的，只不过适用情景不一样。 第一种方法针对单一工程排除文件，这种方式会让这个工程的所有修改者在克隆代码的同时，也能克隆到过滤规则，而不用自己再写一份，这就能保证所有修改者应用的都是同一份规则，而不是张三自己有一套过滤规则，李四又使用另一套过滤规则，个人比较喜欢这个。配置步骤如下： 在工程根目录下建立.gitignore文件，将要排除的文件或目录 写到.gitignore这个文件中，其中有两种写入方法。 a)使用命令行增加排除文件排除以.class结尾的文件 echo “*.class” &gt;.gitignore (&gt;&gt; 是在文件尾增加,&gt; 是删除已经存在的内容再增加)，之后会在当前目录下生成一个.gitignore的文件。排除bin目录下的文件 echo “bin/” &gt;.gitignore b)最方便的办法是，用记事本打开，增加需要排除的文件或目录，一行增加一个。第二种方法全局设置排除文件，这会在全局起作用，只要是Git管理的工程，在提交时都会自动排除不在控制范围内的文件或目录。这种方法对开发者来说，比较省事，只要一次全局配置，不用每次建立工程都要配置一遍过滤规则。但是这不保证其他的开发者在克隆你的代码后，他们那边的规则跟你的是一样的，这就带来了代码提交过程中的各种冲突问题。配置步骤如下： a）像方法（1）一样，也需要建立一个.gitignore文件，把要排除的文件写进去。b）但在这里，我们不规定一定要把.gitnore文件放到某个工程下面，而是任何地方，比如我们这里放到了Git默认的Home路径下，比如：/home/wangshibo/hqsb_iosc）使用命令方式可以配置全局排除文件 git config –global core.excludesfile ~/.gitignore，你会发现在~/.gitconfig文件中会出现excludesfile = /home/wangshibo/hqsb_ios/.gitignore。说明Git把文件过滤规则应用到了Global的规则中。 第三种方法单个工程设置排除文件，在工程目录下找到.git/info/exclude，把要排除的文件写进去： 这种方法就不提倡了，只能针对单一工程配置，而且还不能将过滤规则同步到其他开发者，跟方法（1）（2）比较起来没有一点优势。 .gitignore规则不生效的解决办法把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被追踪的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未被追踪状态），然后再提交： 123git rm -r --cached .git add .git commit -m 'update .gitignore' 注意：不要误解了 .gitignore 文件的用途，该文件只能作用于 Untracked Files，也就是那些从来没有被 Git 记录过的文件（自添加以后，从未 add 及 commit 过的文件）。如果文件曾经被 Git 记录过，那么.gitignore 就对它们完全无效。","categories":[{"name":"网络技术","slug":"网络技术","permalink":"https://ycg31.oschina.io/categories/网络技术/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ycg31.oschina.io/tags/git/"}]},{"title":"如何免费打造打造一个安全稳定低延迟超高速的科学上网环境","slug":"如何免费打造打造一个安全稳定低延迟超高速的科学上网环境","date":"2017-08-20T09:07:09.000Z","updated":"2017-08-20T09:07:57.916Z","comments":true,"path":"2017/08/20/如何免费打造打造一个安全稳定低延迟超高速的科学上网环境/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/如何免费打造打造一个安全稳定低延迟超高速的科学上网环境/","excerpt":"","text":"如何免费打造打造一个安全稳定低延迟超高速的科学上网环境这篇文章将会介绍如何获取由 Google 提供的一年 $300 美金的试用金，然后使用 HyperApp 搭建一个低延迟超高速的科学上网环境。网络延迟基本在50ms左右，并且可以流畅观看 Youtube 4K 视频。本文不需要读者有较深的技术背景，全部过程都可视化、自动化完成。 下文用 GCP 代表 Google Cloud Platform，指 Google 的整个云平台。GCE 是指 Google Cloud Engine，是 GCP 产品线里的一个主机产品。 本文前提条件 有一个 Google 账号，没有的话可以注册一个。 注册 GCP 免费试用需要用信用卡进行身份验证（只做验证，不会收费），所以你必须有一个 Visa/MasterCard 的信用卡才行。 本文目录 GCP 注册以及创建服务器 注册 GCP 新建主机 HyperApp 添加服务器到 HyperApp 配置公钥 开启 BBR 加速，跑满带宽 部署科学上网应用 客户端设置 常见问题 GCP 注册以及创建服务器要访问 Google 首先需要你能科学上网，但是这篇文章又是介绍如何科学上网的，好像有点🐔生蛋蛋生🐔的矛盾… 其实你可以去App Store搜索 V屁恩，找一个免费的下载后，通过签到等方式暂时领取一天或者几个小时的免费低速试用来完成下面的教程。 注册 GCP 免费试用 登录Google账号后使用这个链接来注册 https://cloud.google.com/free/ ，在打开的页面中点击“Try it Free”。 接受条款，并点击”同意并继续“ 在页面中填入你的信息： 账号类型：个人 名称和地址：填写你的地址、电话等 付款方式：添加一个信用卡。这个信用卡将会用来验证身份，防止GCP被滥用。 点击 ”开始免费使用“ 完成注册 在后面的页面中，如果你能看到页面顶部有一个“礼物 🎁 ” 的小图标，说明已经获取了试用金。 新建主机 按照上图所示，在左侧菜单中导航到 计算引擎 → VM 实例 点击加号按钮，创建一个 VM 实例。 名称：随意填入一个易记得名字 地区：建议选择 asia-east1-* 三个中的任意一个，这个机房是在台湾，国内的延迟只有 50~70ms，简直快到飞起。 机器类型：选择 “小型” (1.7G 内存) 就可以了。默认选中的 3.75G 的内存其实用不完。（只用SS的话建议选最低配置的，这样每月大约可以留出来80G流量） 启动磁盘：默认的Debian 8就可以，推荐 Ubuntu 16.04 或者 CentOs 7，但是为了防止将来磁盘不够用，你可以点击右下角的更改，大小里使用 20G 或者 30G。 防火墙：选中 “允许HTTP流量” 和 “允许HTTPS流量” 注意：GCE 的 CentOS 有各种小问题，如果你执意要用 CentOS 遇到问题请自行 Google 点击”创建“，稍等几分钟就会创建完毕，现在打开 HyperApp 开始配置这台服务器吧。 HyperAppHyperApp 是一个部署自动化以及服务器监控管理的App，致力于让普通用户也可以使用云服务。HyperApp 可以监控服务器/路由器的运行状态，还可以可视化的一键部署各种应用。 本段介绍如何使用 HyperApp 管理刚刚创建的服务器，开启 BBR 加速，安装科学上网应用。 添加服务器到 HyperApp 在 “服务器” 页面点击右下角的加号，然后选择第二个”自动配置“ 点击“开始”，应用会自动生成一对密钥，请耐心等到几秒~十几秒。 等到出现“一切就绪”时，点击“复制“将代码复制到剪贴板里，如果你用电脑操作的话可以点击”发送“将代码通过任意一种方式发送到电脑上。 在 GCE 计算引擎 → VM 实例 页面，选择刚刚创建的实例的 SSH ▽ 在浏览器窗口中打开 打开一个基于 Web 的 SSH 终端。 在浏览器的SSH中粘贴并运行刚刚复制的代码。等到二维码出现时，使用 HyperApp 扫描该二维码便会自动添加该服务器。添加后 HyperApp 会检测刚刚添加的服务器的基本运行状况。 永久添加公钥注意：你可以暂时跳过本小段，进行后续的操作，如果 HyperApp 出现了密钥认证错误的提示，可以回到这段进行操作。 刚刚的自动配置的功能在几乎所有主机上都可以用，但是 GCE 是个例外，它会清空用户自行添加的公钥，所以几分钟后可能就会出现密钥认证失败的错误。你可以通过以下步骤永久性的设置密钥。 打开 HyperApp → 更多 → SSH Keys → 点击唯一的一个 Key → 复制公钥。 打开 GCP → 计算引擎 → 元数据 → SSH 密钥 点击修改后，复制并添加刚刚的公钥。 添加后页面会出现一行新记录，主要有两列：用户名 和 密钥。然后确保 HyperApp → 服务器 → 点击服务器下面的齿轮按钮 用户名为这儿显示的用户名，保存后就可以了。（如果你按照上面的步骤操作，HyperApp 自动修改用户名所以这两个用户名应该默认是一致的） 添加以后同一账号下所有新建的主机都可以不用再次操作了。 开启 BBR 加速，跑满带宽这一步并不影响科学上网，但是会极大的提高上网质量。BBR是 Google 开发的TCP拥塞控制技术，并且已经合并到较新的Linux内核中。它的主要作用是可以让你跑满服务器的带宽。 比如说没有开启的情况下你观看 Youtube 720P的视频都可能会卡，但是开启了BBR后 1080P 的视频完全无卡顿，就连 4K 视频也可以流畅观看（有些网络特别卡的除外）。 要开启 BBR 需要升级 Linux 内核，不过不用急，在 HyperApp 中开启非常简单： 在服务器卡片中点击右上角的 Terminal 图标，进入 SSH 终端。 选择最下面的一行工具栏的第一个图标，然后点击 “teddyun/BBR” 一键脚本的链接，点击后会让你确认是否下载并执行外部脚本。 点击确认后会自动下载并执行，执行过程中需要点击键盘上回车键确认继续。如果想中断执行，那么点击 ctrl 后按 c终止执行。 稍等几分钟，等待系统内核升级到最新版后会自动重启（重启时终端会显示Done 和 Shell Closed）然后关闭窗口即可。 如果你想确认 BBR 有没有安装成功，那么再次进入 SSH 终端，输入 lsmod | grep bbr 如果能看到一行记录就是成功了。 注意：一定要先升级BBR再安装应用，反过来会出错，如果你不小心操作错了顺序，请参考 排错指引。 部署科学上网应用 在 HyperApp → 商店 页面 网络 分组下选择任意一个应用，这里我们选择占用资源最少的 ****-libev，（下文用SS代替）点击该应用。在弹出的对话框中选择刚刚添加的服务器，点击创建应用 在此页面中输入简单的一些配置： Port: 端口，可以填入 80 或者 443（因为用其它端口需要设置防火墙） Password：随便填入一个密码 Encrypt：选择一种加密方式，推荐针对移动访问优化的 chacha20 OBFS: 使用 OBFS 可以将 SS 流量伪装成正常的网页访问从而达到欺骗效果，可以防止被墙或者运营商干扰。 如果你使用其它端口，请参考文末的 设置GCE防火墙 如何开启防火墙。 如果安装的过程中出现错误，可以截图后进群寻求帮助，但最快的方式依然是：建一个新的vm重来一遍！真的，很神奇的！ 客户端设置iOSiOS 上有很多 SS 的客户端可供选择，收费的有 小火箭、土豆丝、Surge等。免费的可以使用 Wingy。 配置很简单，只需要点击应用卡片里的服务器栏，然后选择顶部的QR，截图后用其它客户端扫码即可。 如果你想手动配置，请按指示填写参数即可，下面和配置和上面 【部署科学上网应用】段落里第2步的配置一一对应： 服务器：填入你的服务器外部 IP（GCP后台 VM列表页面有一列外部IP，就是那个）。 端口：上面配置界面里面的端口（80，或者443） 密码：上面配置界面里面的密码 加密方式：上面配置界面里面的加密方式 Mac/WindowsMac 和 Windows 上都有免费的 SS 客户端可以使用，配置方法也是只要输入你的IP、端口、密码和加密方式即可。 常见问题：如何建多个账号？你可以创建多个应用给不同的人使用，一个应用只占 1~2M 内存（但注意每个应用的端口必须不同） 信用卡被扣一美元？这是验证信用卡信息是否正确的，快则几分钟慢则几小时就会退款。 结算账号被关闭怎么办？你可能没仔细填信用卡信息，查看你的邮箱应该会有一封谷歌的通知邮件，按照提示传下资料，几个小时左右就会被解封了。 其它玩法现在你有了一台 1.75G 内存的服务器了，只用来做SS好像有点浪费（SS只占用几M内存），其实使用 HyperApp 还有很多其它玩法，商店里面有很多其它应用，都可以自动安装配置。 比如你可以自己搭建一个博客、网站、论坛，个人网盘，聊天服务，并且可以自动配置HTTPS。如果你玩游戏可以创建一个 Minecraft 服务器。或者部署一个接收微信消息转发到Telegram的机器人。更多信息可以参阅👇 的 HyperApp 文档和教程。 HyperApp 支持官方文档和教程Telegram 群 Twitter @HyperApp 如果你遇到了各种各样的技术问题，比如无法安装、无法连接等，可以在群里召唤机器人或者开发者进行解答。或者在App里面点击 发送反馈邮件 获取帮助，这两种是最快的获取帮助的方式。 设置 GCE 防火墙 在GCP后台点击 网络 → 防火墙规则 点击 1创建防火墙规则 名称：随便输入一个名称 目标：选择 网络中的所有示例 来源过滤：0.0.0.0/0 协议和端口：指定的协议和端口 下面输入 tcp;udp:端口号 自建和购买商业服务对比有什么优势？ 最主要的优势是隐私和安全，如果你看下上面SS的日志，你就知道服务商可以知道你的所有浏览历史的，如果你访问了不支持HTTPS的网站，那么请求内容也可能被监控（比如密码信息）。 另外是质量和成本，很多商家是使用和上面同样的机器但是卖给几百个人，你应该能明白了。成本方面没有免费试用的话1个人用可能会有点贵，但如果和朋友家人一起用就超值了，比如使用$2.5/月的 Vultr，每月500G 流量够很多人用的。","categories":[{"name":"代理技术","slug":"代理技术","permalink":"https://ycg31.oschina.io/categories/代理技术/"}],"tags":[{"name":"GCP","slug":"GCP","permalink":"https://ycg31.oschina.io/tags/GCP/"}]},{"title":"Git远程操作详解","slug":"Git远程操作详解","date":"2017-08-19T23:22:09.000Z","updated":"2017-08-20T05:48:19.466Z","comments":true,"path":"2017/08/20/Git远程操作详解/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/Git远程操作详解/","excerpt":"","text":"Git是目前最流行的版本管理系统，学会Git几乎成了开发者的必备技能。 Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。 git clone git remote git fetch git pull git push 本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。 一、git clone远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。 123&gt; $ git clone &lt;版本库的网址&gt;&gt;&gt; 比如，克隆jQuery的版本库。 123&gt; $ git clone https://github.com/jquery/jquery.git&gt;&gt; 该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。 123&gt; $ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;&gt;&gt; git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。 123456789&gt; $ git clone http[s]://example.com/path/to/repo.git/&gt; $ git clone ssh://example.com/path/to/repo.git/&gt; $ git clone git://example.com/path/to/repo.git/&gt; $ git clone /opt/git/project.git &gt; $ git clone file:///opt/git/project.git&gt; $ git clone ftp[s]://example.com/path/to/repo.git/&gt; $ git clone rsync://example.com/path/to/repo.git/&gt;&gt; SSH协议还有另一种写法。 123&gt; $ git clone [user@]example.com:path/to/repo.git/&gt;&gt; 通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。 二、git remote为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。 不带选项的时候，git remote命令列出所有远程主机。 1234&gt; $ git remote&gt; origin&gt;&gt; 使用-v选项，可以参看远程主机的网址。 12345&gt; $ git remote -v&gt; origin git@github.com:jquery/jquery.git (fetch)&gt; origin git@github.com:jquery/jquery.git (push)&gt;&gt; 上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。 克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。 12345&gt; $ git clone -o jQuery https://github.com/jquery/jquery.git&gt; $ git remote&gt; jQuery&gt;&gt; 上面命令表示，克隆的时候，指定远程主机叫做jQuery。 git remote show命令加上主机名，可以查看该主机的详细信息。 123&gt; $ git remote show &lt;主机名&gt;&gt;&gt; git remote add命令用于添加远程主机。 123&gt; $ git remote add &lt;主机名&gt; &lt;网址&gt;&gt;&gt; git remote rm命令用于删除远程主机。 123&gt; $ git remote rm &lt;主机名&gt;&gt;&gt; git remote rename命令用于远程主机的改名。 123&gt; $ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;&gt;&gt; 三、git fetch一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。 123&gt; $ git fetch &lt;远程主机名&gt;&gt;&gt; 上面命令将某个远程主机的更新，全部取回本地。 git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。 默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。 123&gt; $ git fetch &lt;远程主机名&gt; &lt;分支名&gt;&gt;&gt; 比如，取回origin主机的master分支。 123&gt; $ git fetch origin master&gt;&gt; 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。 git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。 12345678&gt; $ git branch -r&gt; origin/master&gt;&gt; $ git branch -a&gt; * master&gt; remotes/origin/master&gt;&gt; 上面命令表示，本地主机的当前分支是master，远程分支是origin/master。 取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。 123&gt; $ git checkout -b newBrach origin/master&gt;&gt; 上面命令表示，在origin/master的基础上，创建一个新分支。 此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。 12345&gt; $ git merge origin/master&gt; # 或者&gt; $ git rebase origin/master&gt;&gt; 上面命令表示在当前分支上，合并origin/master。 四、git pullgit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。 123&gt; $ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;&gt;&gt; 比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。 123&gt; $ git pull origin next:master&gt;&gt; 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。 123&gt; $ git pull origin next&gt;&gt; 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。 1234&gt; $ git fetch origin&gt; $ git merge origin/next&gt;&gt; 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。 Git也允许手动建立追踪关系。 123&gt; git branch --set-upstream master origin/next&gt;&gt; 上面命令指定master分支追踪origin/next分支。 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。 123&gt; $ git pull origin&gt;&gt; 上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。 如果当前分支只有一个追踪分支，连远程主机名都可以省略。 123&gt; $ git pull&gt;&gt; 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。 如果合并需要采用rebase模式，可以使用--rebase选项。 123&gt; $ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;&gt;&gt; 如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。 但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。 123456&gt; $ git pull -p&gt; # 等同于下面的命令&gt; $ git fetch --prune origin &gt; $ git fetch -p&gt;&gt; 五、git pushgit push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。 123&gt; $ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;&gt;&gt; 注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。 如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 123&gt; $ git push origin master&gt;&gt; 上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。 12345&gt; $ git push origin :master&gt; # 等同于&gt; $ git push origin --delete master&gt;&gt; 上面命令表示删除origin主机的master分支。 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 123&gt; $ git push origin&gt;&gt; 上面命令表示，将当前分支推送到origin主机的对应分支。 如果当前分支只有一个追踪分支，那么主机名都可以省略。 123&gt; $ git push&gt;&gt; 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。 123&gt; $ git push -u origin master&gt;&gt; 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。 不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。 12345&gt; $ git config --global push.default matching&gt; # 或者&gt; $ git config --global push.default simple&gt;&gt; 还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用--all选项。 123&gt; $ git push --all origin&gt;&gt; 上面命令表示，将所有本地分支都推送到origin主机。 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。 123&gt; $ git push --force origin &gt;&gt; 上面命令使用--force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用--force选项。 最后，git push不会推送标签（tag），除非使用--tags选项。 123&gt; $ git push origin --tags&gt;&gt; （完）","categories":[{"name":"网络技术","slug":"网络技术","permalink":"https://ycg31.oschina.io/categories/网络技术/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ycg31.oschina.io/tags/git/"}]},{"title":"git pull 和 clone的区别及用法","slug":"git pull和clone的区别及用法","date":"2017-08-19T21:22:09.000Z","updated":"2017-08-20T05:47:49.850Z","comments":true,"path":"2017/08/20/git pull和clone的区别及用法/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/git pull和clone的区别及用法/","excerpt":"","text":"一、git pullgit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。 完整格式：$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 完整格式举例：比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样， （1）$ git pull origin next:master：如果远程分支是与当前分支合并，则冒号后面的部分可以省略。（2）$ git pull origin next：上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。12$ git fetch origin$ git merge origin/next 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。 Git也允许手动建立追踪关系，git branch –set-upstream master origin/next上面命令指定master分支追踪origin/next分支。如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。 1$ git pull origin 上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”(remote-tracking branch)进行合并。如果当前分支只有一个追踪分支，连远程主机名都可以省略。 二、get clone远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。 ##（1）$ git clone &lt;版本库的网址&gt;比如，克隆jQuery的版本库。1$ git clone https://github.com/jquery/jquery.git 该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。 （2）$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。1234567$ git clone http[s]://example.com/path/to/repo.git/$ git clone ssh://example.com/path/to/repo.git/$ git clone git://example.com/path/to/repo.git/$ git clone /opt/git/project.git$ git clone file:///opt/git/project.git$ git clone ftp[s]://example.com/path/to/repo.git/$ git clone rsync://example.com/path/to/repo.git/ （3）SSH协议还有另一种写法。1$ git clone [user@]example.com:path/to/repo.git/ 通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。","categories":[{"name":"网络技术","slug":"网络技术","permalink":"https://ycg31.oschina.io/categories/网络技术/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ycg31.oschina.io/tags/git/"}]},{"title":"远程GitHub中的灰色图标的解决办法","slug":"远程GitHub中的灰色图标的解决办法","date":"2017-08-19T21:22:09.000Z","updated":"2017-08-20T05:48:02.687Z","comments":true,"path":"2017/08/20/远程GitHub中的灰色图标的解决办法/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/远程GitHub中的灰色图标的解决办法/","excerpt":"","text":"问题描述任何人都可以告诉我为什么我把我的文件推送到github时有灰色图标？在应用程序目录中，应该有模型，视图和控制器，但在远程GitHub中，我无法点击。 最佳解决方案看起来你创建了一个子模块，指向一个不可达的远程位置。 见this answer。该图标在绿色时将指向子模块。因为子模块配置不正确，我认为你的情况是灰色的。 鉴于.gitmodules不存在，它必须被删除，留下没有远程信息的子模块。 如果进入app并键入git remote -v，您将看到该模块指向的位置。这个地方目前无法到达。 在类似的情况下，我添加了一个子模块并删除了.gitmodules。 GitHub的结果如下所示： 次佳解决方案看起来你在文件夹中初始化了git。从子文件夹中删除git文件(rm -rf)，并创建一个新的repo并重新初始化git。 第三种解决方案1git rm --cached &lt;folder_name&gt; 然后转到父目录，然后执行： 123git add .git commit -m \"&lt;your_message&gt;\"git push --all","categories":[{"name":"网络技术","slug":"网络技术","permalink":"https://ycg31.oschina.io/categories/网络技术/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ycg31.oschina.io/tags/git/"}]},{"title":"使用AppVeyor自动部署Hexo到Github","slug":"使用AppVeyor自动部署Hexo到Github","date":"2017-08-19T20:22:09.000Z","updated":"2017-08-20T05:47:31.909Z","comments":true,"path":"2017/08/20/使用AppVeyor自动部署Hexo到Github/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/使用AppVeyor自动部署Hexo到Github/","excerpt":"","text":"一、转载别人的教程想必很多人会把Hexo生成出来的静态网站放到GitHub Pages来进行托管。一般发布Hexo博客的流程是，首先在本地搭建Hexo的环境，编写新文章，然后利用hexo deploy来发布到Git。那么对于本地的Hexo的原始文件怎么管理呢？如果换电脑了怎么办？如果没有对原始文件进行备份，突然有一天你的本地环境挂了导致源文件丢失，那不就呵呵了。也许你会想到用Dropbox或者其他方案来对源文件进行备份，但是每次更新完博客，需要备份好源文件，然后执行hexo deploy进行发布，是不是很麻烦？换了电脑之后又要重新搭建本地环境，是不是很蛋疼？ 那么接下来我们就来说说如何优雅愉快地对我们的Hexo进行版本管理和发布。 ​ 既然我们已经用了GitHub来托管我们生成出来的静态网站，那么为什么不也把Hexo博客的源文件也host在GitHub上呢。那么问题来了，如果我们把Hexo博客的源文件托管在GitHub上，我们的发布流程就会变为： 执行git push把更新的源文件push到托管源文件的GitHub Repo (我们称之为Source Repo) 执行hexo deploy来更新托管静态网站的GitHub Pages (我们称之为Content Repo) ​ 这样看来，每次更新博客要经历两个步骤，并不是那么straightforward。那么有没有办法做到既能使用GitHub进行版本控制，又能做到一键发布呢？ ​ 答案是肯定的。这里用到了持续集成也就是我们一直所说的CI来完成一键发布：当有新的change push到Source Repo时，自动执行CI脚本，生成最新的静态网站发布到Content Repo，一气呵成。那么我使用什么CI工具来做呢？我们可以使用像Travis CI这样的Hosted CI Service，也可以使用Jenkins或者TeamCity来搭建CI server。如果自己来搭建CI Server，费时费力，又要花钱来买Server来host CI service，肯定不是一个很好的选择。那么我们选哪个Hosted CI Service呢？其实今年在公司的一个项目中我们就选择了AppVeyor。当初在做investigation的时候，第一个想到的就是用Travis CI，然而我司大多数的开发环境都是Windows，而且当时的项目有Python, PowerShell, Java等，那时PowerShell还只支持Windows，所以需要选择一个支持Windows的CI Service。于是，Scott Hanselman安利的AppVeyor就成为了一个备选。访问AppVeyor官网，映入眼帘的大标题就是#1 Continuous Delivery service for Windows。刚开始的时候内心一阵嘲笑，Top 10的CI Service就你支持Windows，你不是第一那谁是第一？结果在之后的项目使用中，发现AppVeyor比Travis CI好用太多。这里就不具体展开了，继续进入正题。 ​ 使用AppVeyor来建立CI非常方便，主要是以下步骤： 1. 注册并登陆AppVeyor 访问AppVeyor登陆页面，使用你的GitHub账号登陆即可。 ​ 2. 添加Project 在AppVeyor Projects页面，添加相应的GitHub Source Repo。 ​ ## 3. 添加appveyor.yml到Source Repo 接下来，你需要把appveyor.yml添加到Source Repo的根目录下。具体的appveyor.yml如下: 1234567891011121314151617181920212223242526272829clone_depth: 5environment:access_token: secure: [Your GitHub Access Token]install:- node --version- npm --version- npm install- npm install hexo-cli -gbuild_script:- hexo generateartifacts:- path: public on_success:- git config --global credential.helper store- ps: Add-Content \"$env:USERPROFILE\\.git-credentials\" \"https://$($env:access_token):x-oauth-basic@github.com`n\"- git config --global user.email \"%GIT_USER_EMAIL%\"- git config --global user.name \"%GIT_USER_NAME%\"- git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site- cd %TEMP%\\static-site- del * /f /q- for /d %%p IN (*) do rmdir \"%%p\" /s /q- SETLOCAL EnableDelayedExpansion &amp; robocopy \"%APPVEYOR_BUILD_FOLDER%\\public\" \"%TEMP%\\static-site\" /e &amp; IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1))- git add -A- git commit -m \"Update Static Site\" - git push origin %TARGET_BRANCH%- appveyor AddMessage \"Static Site Updated\" 你唯一需要做的就是替换[Your GitHub Access Token]，关于生成Access Token，可以参考这篇文章。在GitHub生成好Access Token之后，你需要到AppVeyor加密页面把Access Token加密之后再替换[Your GitHub Access Token] ​ 4. 设置Appveyor 添加好appveyor.yml之后，再到Appveyor portal设置以下四个变量。STATIC_SITE_REPO就是Content Repo的地址，TARGET_BRANCH就是你Content Repo的branch，一般默认就是master，GIT_USER_EMAIL和GIT_USER_NAME就是你GitHub账号的信息。 ​ 好了，一切大功告成！试一下git push你的change到Source Repo，几分钟内，你的博客就自动更新了！ 背后的过程如下: Git push to Source Repo –&gt; AppVeyor CI –&gt; Update GitHub Pages Content Repo –&gt; Generate your Hexo blog site 折腾过程中遇到的问题部署成功后，所有创建的html文件全部是空的，几经周折才发现，原来是缺少主题文件，所有生成的html文件全是空的，提示错误WARN No layout，再到GitHub上一看，主题文件夹变成了灰色。具体如何解决灰色文件夹可以参考我转载的另一篇文章。","categories":[{"name":"网络技术","slug":"网络技术","permalink":"https://ycg31.oschina.io/categories/网络技术/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ycg31.oschina.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://ycg31.oschina.io/tags/hexo/"},{"name":"appveyor","slug":"appveyor","permalink":"https://ycg31.oschina.io/tags/appveyor/"}]},{"title":"使用Travis CI自动部署Hexo","slug":"使用Travis-CI自动部署Hexo","date":"2017-08-19T19:41:09.000Z","updated":"2017-08-20T06:45:39.365Z","comments":true,"path":"2017/08/20/使用Travis-CI自动部署Hexo/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/使用Travis-CI自动部署Hexo/","excerpt":"","text":"前两天了解到了一个有趣的概念叫持续集成： 持续集成是一种软件开发实践。在持续集成中，团队成员频繁集成他们的工作成果，一般每人每天至少集成一次，也可以多次。每次集成会经过自动构建（包括自动测试）的检验，以尽快发现集成错误。许多团队发现这种方法可以显著减少集成引起的问题，并可以加快团队合作软件开发的速度。这篇文章简要介绍了持续集成的技巧和它最新的应用。 然后想到我的博客也恰好满足这样的需求，因为我的博客一旦有了修改，就必须要重新build并且部署，那么能不能用持续集成的思想来改造我部署博客的流程呢？ 在这样的指导思想下，我完成了上一篇文章：VPS搭配Github Webhook实现Hexo自动发布，而今天我要介绍一下，在没有VPS的情况下，如何更方便的配置自己的持续集成的博客。 好处 方便：只需要一次配置，便省去了每一次编辑文档后，都需要进行hexo d -g的麻烦，更不必说文章增多之后渲染时间还会增长。 稳定：这个是最近才发现的，Github被搞了之后，很多人反映不能更新博客了，使用Travis CI，你只要想办法提交一个小md文档，就能进行构建。如果自己手动构建，只要一个文件上传失败，前面的工作都白费了。 快捷：即使是出差在外，只要能编辑Markdown，就可以撰写博客，使得Hexo拥有类似于WP一致的体验~ 协作：博客的构建完全交由Travis CI进行，所以完全可以通过Hexo+git构建一个多人协作的博客平台。实际上，Hexo的官网正是这样构建的。 Travis CI介绍 Travis CI是在软件开发领域中的一个在线的，分布式的持续集成服务，用来构建及测试在GitHub托管的代码。这个软件的代码同时也是开源的，可以在GitHub上下载到，尽管开发者当前并不推荐在闭源项目中单独使用它。 它提供了多种编程语言的支持，包括Ruby，JavaScript，Java，Scala，PHP，Haskell和Erlang在内的多种语言。许多知名的开源项目使用它来在每次提交的时候进行构建测试，比如Ruby on Rails，Ruby和Node.js。 2012年，Travis CI 决定进行募资以支持后续的开发，在这次募资活动中，许多重量级的科技公司给予了资助。 需要注意的是几个特性： 只支持Github 支持JavaScript 开源，免费 然后介绍一下它的原理： Travis CI会在你每一次提交之后生成一个虚拟机来执行你事先安排好的build任务，你可以调整这个虚拟机的软件环境，甚至能执行sudo来进行apt-get install。 Travis CI配置我们知道，Hexo的命令非常简单，一个hexo d -g就可以搞定。困难之处在于，Travis CI并没有对你的库进行push操作的权限。如果直接将私钥放在自己的开源库之中，这无异于将自己的代码库提交权限开放给了所有的Github使用者。所以，为了保护自己，我们需要采取一些配置操作。 感谢Hexo作者tommy351提供的操作流程，原文可见于用 Travis CI 自動部署網站到 GitHub Travis CI使用SSH 连接GitHub生成SSH Key参见使用Github SSH Key以免去Hexo部署时输入密码 需要注意的是，这个SSH key不应成为你账号的全局SSH key（因为这样Travis CI就获得了你所有代码库的提交权限，这是不正确的），而应该添加至https://github.com/username/ropename/settings/keys ，这样，你就控制了Travis CI的权限。 ###加密私钥 下面的操作需要事先配置好gem环境，如果没有可以尝试使用强大且配置项丰富的在线IDE应用——Cloud9。 安装Travis CI的命令行工具1gem install travis # 安装travis 登陆Travis CI需要输入Github账号和密码 1travis login --auto 加密私钥并上传至Travis正确生成后你会得到两个文件，一个叫ssh_key，一个叫ssh_key.pub。刚才我们将ssh_key.pub添加到了github，下面我们要加密ssh_key这个私钥并且上传到Travis。 1travis encrypt-file ssh_key --add 然后Travis的客户端会自动检测当前目录中的git信息，并且添加到.travis.yml中去。在进行此步操作前，目录下要先存在.travis.yml文件，否则会报错。 指定SSH设置在当前目录下新建文件ssh_config，内容为 12345Host github.com User git StrictHostKeyChecking no IdentityFile ~/.ssh/id_rsa IdentitiesOnly yes 然后指定openssl解密后的生成位置，修改Travis自动插入的解密指令(不要照抄，注意修改密钥) 12- openssl aes-256-cbc -K $encrypted_xxxxxxxxxx_key -iv $encrypted_xxxxxxxxxx_iv -in travis.enc -out ~/.ssh/id_rsa -d 修改目录权限紧跟那条解密指令，换行输入： 1- chmod 600 ~/.ssh/id_rsa 注意yml格式，短杠后面的空格不能省略。 将密钥加入系统紧跟上一步操作，换行输入： 12- eval $(ssh-agent)- ssh-add ~/.ssh/id_rsa 修改git信息将之前创建的ssh_config复制到Travis的虚拟机中去，输入： 1- cp ssh_config ~/.ssh/config 然后指定git使用者信息： 12- git config --global user.name \"username\"- git config --global user.email username@example.com Build配置之前的所有操作都只是为了让Travis CI拥有push权限，下面我们开始进入到真正的Build配置当中。 之前我们用到了一个名为.travis.yml的文件，跟build有关的所有设置都在这个文件里面，下面的操作都在这个文件当中进行。 指定环境在文件中添加如下代码： 1234language: node_jsnode_js:- '0.10' //指定使用node.js最新的稳定版0.10 指定分支在文件中添加如下代码： 123branches: only: - blog //这个分支应当使用自己的源文件分支 差点忘了讲- -，本方案只适用于用github来托管自己自己的hexo目录的用户。这里的分支应该使用包含有.md文档的那个分支。 Hexo配置首先在虚拟机中安装Hexo： 1234install:- npm install hexo-cli -g- npm install hexo --save- npm install 然后执行Hexo的渲染操作 1234script:- hexo clean //分开写，方便调试可能出现的错误- hexo d- hexo g 到这里，你的Travis CI的持续集成已经配置完毕了，最后的.travis.yml文件内容可以参考如下： 123456789101112131415161718192021222324252627282930313233branches: only: - blog # 这里是你监视的分支，只有blog分支更改才触发自动部署language: node_jssudo: falsenode_js:- '0.12' before_install:- openssl aes-256-cbc -K $encrypted_xxxxxxxxx_key -iv $encrypted_xxxxxxx_iv -in doc/travis.enc -out ~/.ssh/id_rsa -d- chmod 600 ~/.ssh/id_rsa- eval $(ssh-agent)- ssh-add ~/.ssh/id_rsa- cp doc/ssh_config ~/.ssh/config- git config --global user.name \"yourname\"- git config --global user.email youremail- git clone -b master git@github.com:yourname/yourrepo.git .deploy_gitinstall:- npm install hexo-cli -g- npm install- npm install hexo-generator-feed --save- npm install hexo-generator-sitemap --save- npm install hexo-deployer-git --savescript:- hexo clean- hexo g- hexo d Travis CI使用Token 连接GitHub 安装travisTravis安装需要Ruby环境，所有需要安装Ruby,并且需要安装rubygems插件。 12# 安装travisgem isntall travis 新建配置文件首先打开博客项目文件夹，在项目根目录新建.travis.yml配置文件。 12$ cd 博客项目文件夹根目录$ touch .travis.yml 登录travis1travis login --auto 然后会提示输入github的用户名和密码。 新建变量在项目根目录下执行: 123# 这里的 REPO_TOKEN 是变量名,在后面的配置文件中会用到# TOKEN 是上面github生成的Tokentravis encrypt 'REPO_TOKEN=&lt;TOKEN&gt;' --add 此操作会在.travis.yml文件中添加下面的信息 123env:global: secure: fxBE17yzFhC2+FjwVLYbgIhggyfliv3dFCDozTJD7U3n 编辑配置文件​ 打开Travis配置文件.travis.yml，添加如下信息： 1234567891011121314151617181920212223242526272829language: node_jsnode_js:- \"4\" # nodejs的版本branches: only: - dev # 设置自动化部署的源码分支env: global: secure: [加密后的Token]before_install:- export TZ='Asia/Shanghai' # 设置时区- npm install -g hexo- npm install -g hexo-clibefore_script:# 设置github账户信息- git config --global user.name \"SeayXu\" #设置github用户名- git config --global user.email SeayXu@163.com #设置github用户邮箱# github仓库操作- sed -i'' \"s~git@github.com:SeayXu/seayxu.github.io.git~https://$&#123;REPO_TOKEN&#125;:x-oauth-basic@github.com/SeayXu/seayxu.github.io.git~\" _config.yml# 安装依赖组件install:- npm install# 执行的命令script:- hexo clean- hexo generate# 执行的成功后执行 after_success:- hexo deploy 完整配置文件可以参考这个。 转载备用，这个我没配置，因为手上没Lunix系统，等回头装个的虚拟机尝试下，我是用AppVeyor。","categories":[{"name":"网络技术","slug":"网络技术","permalink":"https://ycg31.oschina.io/categories/网络技术/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ycg31.oschina.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://ycg31.oschina.io/tags/hexo/"},{"name":"Travis","slug":"Travis","permalink":"https://ycg31.oschina.io/tags/Travis/"}]},{"title":"GIT相关命令","slug":"GIT相关命令","date":"2017-08-19T19:24:09.000Z","updated":"2017-08-20T05:46:13.694Z","comments":true,"path":"2017/08/20/GIT相关命令/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/GIT相关命令/","excerpt":"","text":"查看所有分支1git branch -a 查看本地分支1git branch 查看远程分支123git remote git remote -v # 带详细信息 添加远程仓库123git remote add [shortname][url]git remote add pb git://github.com/paulboone/ticgit.git #名字为pb 地址为git://github.com/paulboone/ticgit.git 创建分支1git branch test # text为分支名称 切换分支1git checkout test 当前分支推送到远程分支1git checkout test 删除本地分支123git branch -d xxxxx或 git br -d xxxxx 删除远程版本1git push origin :br-1.0.0 删除远程分支123git branch -r -d origin/branch-name git push origin :branch-name #推送一个空的本地分支到远程分支就是删除远程分支","categories":[{"name":"网络技术","slug":"网络技术","permalink":"https://ycg31.oschina.io/categories/网络技术/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ycg31.oschina.io/tags/git/"}]},{"title":"使用Travis自动部署hexo","slug":"使用Travis自动部署hexo","date":"2017-08-19T19:22:09.000Z","updated":"2017-08-20T05:46:11.138Z","comments":true,"path":"2017/08/20/使用Travis自动部署hexo/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/使用Travis自动部署hexo/","excerpt":"","text":"转载自http://blog.csdn.net/xuezhisdc/article/details/53130423 新建Personal Access Token 点击右上角头像旁边的三角，在菜单中点击“Setting”，进入设置页面。 点击左侧栏的最下面的“Personal access tokens”，创建Personal access tokens。 点击右上角的“Generate new token”，输入用户密码，进入“New personal access token”页面。 设置Token description（其实就是名称），选择相应的权限，如下图所示。 点击“Generate token”按钮，生成Personal access tokens。如下图中红线标注的部分。注意：这行token只会在刚刚创建完成后显示一次，以后不再显示。因此，复制并保存到本地。 配置Travis CI登录并配置Travis CI Travis CI是目前新兴的开源持续集成构建项目。可以直接使用GitHub账号登录。 将鼠标放在用户名上，在弹出的菜单中点击“Accounts”，将会显示你在GitHub上的仓库。如下图所示。 找到自己的博客项目，点击X号，将其变成√号。再点击右侧的齿轮，进入该仓库的配置页面。 在项目的设置中开启Build only if .travis.yml is present这一项。如下图所示。 本地安装Travis 首先安装Ruby，直接官网下载，双击安装就OK了。 在Windows下，安装travis之前，需要解决一个问题：SSL证书问题，否则不能成功安装。详情请点击该链接：参考教程。 修复好上述问题后，执行下面的命令安装travis。 12# 安装travisgem isntall travis1212 创建并修改配置文件 打开博客项目文件夹，在项目根目录新建.travis.yml配置文件。 12cd 博客项目文件夹根目录touch .travis.yml1212 执行下面的命令，加密上面生成的Personal access tokens，并添加到.travis.yml配置文件。 123# 这里的 REPO_TOKEN 是变量名,在后面的配置文件中会用到# TOKEN 是上面github生成的Tokentravis encrypt 'REPO_TOKEN=&lt;TOKEN&gt;' --add123123 上述命令指向完后，.travis.yml配置文件的内容如下所示。 123env: global: secure: F/gYu+bVe3aWs6YnuB5PNZLEmHH4CGf0najk8JI3/N+SFL0TH8tyYg+O1sXR3EIg.....省略.....iwr5HQG/G3fdL4JcXiAJIm/iH9ndDyGV5EGR1CmseNGNWrwnRZ7tlKE=123123 使用本地编辑器打开.travis.yml配置文件，将其修改成如下所示的内容。注意：有些内容是你自己的!!! 1234567891011121314151617181920212223242526272829303132333435363738language: node_jsnode_js:- \"4\" # nodejs的版本branches: only: - dev # 设置自动化部署的源码分支# ------------------------------------------------# 下面是你的Token加密信息，不要替换# ------------------------------------------------env: global: secure: F/gYu+bVe3aWs6Yn.....省略..../iH9ndDyGV5EGR1CmseNGNWrwnRZ7tlKE=before_install:- export TZ='Asia/Shanghai' - npm install -g hexo- npm install -g hexo-cli before_script:# ------------------------------------------------# 设置github账户信息 注意修改成自己的信息# ------------------------------------------------- git config --global user.name \"xuezhisd\"- git config --global user.email xuezhi@126.com # ------------------------------------------------# github仓库操作 注意将仓库修改成自己的# ------------------------------------------------- sed -i'' \"s~git@github.com:xuezhisd/xuezhisd.github.io.git~https://$&#123;REPO_TOKEN&#125;:x-oauth-basic@github.com/xuezhisd/xuezhisd.github.io.git~\" _config.yml# 安装依赖组件install:- npm install# 执行的命令script:- hexo clean- hexo generate# 执行的成功后执行 after_success:- hexo deploy12345678910111213141516171819202122232425262728293031323334353637381234567891011121314151617181920212223242526272829303132333435363738 1至此，Travis CI已经配置完成了。 创建仓库，推送到GitHub 新建仓库blog。 12git init blogcd blog1212 将原来博客目录下的以下内容复制到blog文件夹中。 修改.gitignore文件，取消对node_modules文件夹的忽略。（即删除对应的行） 关联GitHub上的远程仓库。 12# 将github仓库改为自己的博客仓库git remote add origin git@github.com:xuezhisd/xuezhisd.github.io.git1212 提交本地修改，推送到GitHub上。 123456# 添加文件到暂存区git add .# 提交修改git commit -m \"test travis\"# 推送至远程仓库的dev分支git push -u origin dev123456123456 push本地的代码至远程仓库之后，在https://travis-ci.org 后台查看相关情况。如果如下图所示，就代表成功了。","categories":[{"name":"网络技术","slug":"网络技术","permalink":"https://ycg31.oschina.io/categories/网络技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ycg31.oschina.io/tags/hexo/"},{"name":"Travis","slug":"Travis","permalink":"https://ycg31.oschina.io/tags/Travis/"}]},{"title":"（转）Hexo添加文章时自动打开编辑器","slug":"（转）Hexo添加文章时自动打开编辑器","date":"2017-08-19T19:20:09.000Z","updated":"2017-08-20T05:42:26.919Z","comments":true,"path":"2017/08/20/（转）Hexo添加文章时自动打开编辑器/","link":"","permalink":"https://ycg31.oschina.io/2017/08/20/（转）Hexo添加文章时自动打开编辑器/","excerpt":"","text":"在Hexo中新建一篇博文非常简单，只需要在命令行中键入以下命令然后回车即可： 1hexo new \"The title of your blog\" 此后Hexo便会在Hexo的根目录的source文件夹下的_posts目录下自动帮你创建相应的md文件。然后我们打开该目录，找到刚刚Hexo自动生成的文件打开编辑即可。 但是当我们的博文比较多，这样我们就需要在成堆的Markdown文件中找到刚才自动生成的文件，这样做显然是一件比较痛苦的事情。 首先在Hexo目录下的scripts目录中创建一个JavaScript脚本文件。 如果没有这个scripts目录，则新建一个。 scripts目录新建的JavaScript脚本文件可以任意取名。 通过这个脚本，我们用其来监听hexo new这个动作，并在检测到hexo new之后，执行编辑器打开的命令。 如果你是windows平台的Hexo用户，则将下列内容写入你的脚本： 1234567891011var spawn = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; spawn('start \"markdown编辑器绝对路径.exe\" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; spawn('start \"markdown编辑器绝对路径.exe\" ' + data.path);&#125;); 如果你是Mac平台Hexo用户，则将下列内容写入你的脚本： 12345678910var exec = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; exec('open -a \"markdown编辑器绝对路径.app\" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; exec('open -a \"markdown编辑器绝对路径.app\" ' + data.path);&#125;); 保存并退出脚本之后，在命令行中键入： 1hexo new \"auto open editor test\" 是不是就顺利的自动打开了自动生成的md文件啦~ Enjoy it！ 本文作者： 夏末 本文链接： https://notes.wanghao.work/2015-06-29-Hexo添加文章时自动打开编辑器.html 版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"网站相关","slug":"网站相关","permalink":"https://ycg31.oschina.io/categories/网站相关/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ycg31.oschina.io/tags/hexo/"}]},{"title":"CentOS6上安装V2ray","slug":"CentOS6上安装V2ray","date":"2017-08-19T09:20:09.000Z","updated":"2017-08-20T06:55:45.980Z","comments":true,"path":"2017/08/19/CentOS6上安装V2ray/","link":"","permalink":"https://ycg31.oschina.io/2017/08/19/CentOS6上安装V2ray/","excerpt":"","text":"Centos6下的部署 先说明下，V2Ray提供的一键安装脚本自带守护进程，意思是如果V2Ray如果意外中止，会自动重新启动，这样使用非常方便，但是Centos6下我这种Ctrl CV党实在是不会自己写脚本，采用的是简易运行方式，所以推荐尽量能采用2.1的步骤来安装。 首先我们打开作者的Github项目，找到最新版的V2ray的下载地址 1https://github.com/v2ray/v2ray-core/releases 目前最新版是v2.19，我们找到对应的v2ray-linux-64.zip文件，复制链接地址： 1https://github.com/v2ray/v2ray-core/releases/download/v2.19/v2ray-linux-64.zip 然后我们Root用户Putty登录服务器，root目录下下载文件，代码如下： 1wget https://github.com/v2ray/v2ray-core/releases/download/v2.19/v2ray-linux-64.zip 下载完毕后，我们解压zip文件 1unzip v2ray-linux-64.zip 目录下会多一个目录名，v2ray-v2.19-linux-64（版本不同目录名有版本号的差别），为了后面操作方便，我们把目录名更名 1mv v2ray-v2.19-linux-64 v2ray 进入目录，并对v2ray文件授权123cd /root/v2raychmod +x v2ray 这时候v2ray就能使用了，但是运行v2ray，一旦关闭putty，v2ray就会自动关闭，所以我们需要后台运行，这里采用nohup的方式。123cd /root/v2raynohup ./v2ray &amp; 停止V2ray服务也很简单1killall v2ray 编辑rc.local文件，添加开机启动V2ray1vi /etc/rc.d/rc.local 打开后添加两行123cd /root/v2raynohup ./v2ray &amp; 到这里安装就成功了。下面我们进入下一步，编辑配置文件。 如果使用官网的一键安装脚本无法启动的，可以使用下面这个解决，来自于官网Issues 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#!/bin/sh## v2ray Startup script for v2ray## chkconfig: - 24 76# processname: v2ray# pidfile: /var/run/v2ray.pid# description: V2Ray proxy services#### BEGIN INIT INFO# Provides: v2ray# Required-Start: $network $local_fs $remote_fs# Required-Stop: $remote_fs# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: V2Ray proxy services# Description: V2Ray proxy services### END INIT INFODESC=v2rayNAME=v2rayDAEMON=/usr/bin/v2ray/v2rayPIDFILE=/var/run/$NAME.pidLOCKFILE=/var/lock/subsys/$NAMESCRIPTNAME=/etc/init.d/$NAMERETVAL=0DAEMON_OPTS=\"-config /etc/v2ray/config.json\"# Exit if the package is not installed[ -x $DAEMON ] || exit 0# Read configuration variable file if it is present[ -r /etc/default/$NAME ] &amp;&amp; . /etc/default/$NAME# Source function library.. /etc/rc.d/init.d/functionsstart() &#123; local pids=$(pgrep -f $DAEMON) if [ -n \"$pids\" ]; then echo \"$NAME (pid $pids) is already running\" RETVAL=0 return 0 fi echo -n $\"Starting $NAME: \" mkdir -p /var/log/v2ray $DAEMON $DAEMON_OPTS 1&gt;/dev/null 2&gt;&amp;1 &amp; echo $! &gt; $PIDFILE sleep 2 pgrep -f $DAEMON &gt;/dev/null 2&gt;&amp;1 RETVAL=$? if [ $RETVAL -eq 0 ]; then success; echo touch $LOCKFILE else failure; echo fi return $RETVAL&#125;stop() &#123; local pids=$(pgrep -f $DAEMON) if [ -z \"$pids\" ]; then echo \"$NAME is not running\" RETVAL=0 return 0 fi echo -n $\"Stopping $NAME: \" killproc -p $&#123;PIDFILE&#125; $&#123;NAME&#125; RETVAL=$? echo [ $RETVAL = 0 ] &amp;&amp; rm -f $&#123;LOCKFILE&#125; $&#123;PIDFILE&#125;&#125;reload() &#123; echo -n $\"Reloading $NAME: \" killproc -p $&#123;PIDFILE&#125; $&#123;NAME&#125; -HUP RETVAL=$? echo&#125;rh_status() &#123; status -p $&#123;PIDFILE&#125; $&#123;DAEMON&#125;&#125;# See how we were called.case \"$1\" in start) rh_status &gt;/dev/null 2&gt;&amp;1 &amp;&amp; exit 0 start ;; stop) stop ;; status) rh_status RETVAL=$? ;; restart) stop start ;; reload) reload ;; *) echo \"Usage: $SCRIPTNAME &#123;start|stop|status|reload|restart&#125;\" &gt;&amp;2 RETVAL=2 ;;esacexit $RETVAL Save as /etc/init.d/v2ray and then excute: 123$ sudo chmod +x /etc/init.d/v2ray$ sudo chkconfig v2ray on$ sudo service v2ray start","categories":[{"name":"代理技术","slug":"代理技术","permalink":"https://ycg31.oschina.io/categories/代理技术/"}],"tags":[{"name":"v2ray","slug":"v2ray","permalink":"https://ycg31.oschina.io/tags/v2ray/"}]},{"title":"V2ray使用TLS","slug":"V2ray使用TLS","date":"2017-08-19T06:20:09.000Z","updated":"2017-08-20T05:41:41.701Z","comments":true,"path":"2017/08/19/V2ray使用TLS/","link":"","permalink":"https://ycg31.oschina.io/2017/08/19/V2ray使用TLS/","excerpt":"","text":"1. TLS从 v1.19 起引入了 TLS，TLS 中文译名是传输层安全，如果你没听说过，请 Google 了解一下。以下给出些我认为介绍较好的文章链接： SSL/TLS协议运行机制的概述 传输层安全协议 Shadowsocks 的作者 clowwindy 却认为翻墙不该用 SSL。那么到底该不该用？对此我不作评论，各位自行思考。这里我只教大家如何开启 TLS。 1.1. 注册一个域名如果已经注册有域名了可以跳过。 域名有免费的有付费的，总体来说付费的会优于免费的，具体差别请 Google。如果你不舍得为一个域名每年花点钱，用个免费域名也可以。为了方便，这里我将以免费域名为例。 关于如何注册一个免费域名，我发现有一位网友写得很详细，就不多说了。请参考： 教你申请.tk/.ml/.cf/.gq/.ga等免费域名 至于注册其它付费的域名请 Google 吧，差不多都是大同小异的。 注册好域名之后务必记得设置 DNS 解析到你的 VPS ! 据了解，在 freenom 注册的域名在对应的 IP 上要有一个网站，否则注册之后域名会被回收。如果您只是想用免费域名在 V2Ray 用一下 TLS，又不愿意（懒得、不会）建站，建议您看看您的亲朋好友谁有手上有域名的，向他们要一个二级域名就行了 以下假设注册的域名为 mydomain.me，请将之替换成自己的域名。 1.2. 证书生成使用 TLS 需要证书，证书也有免费付费的，同样的这里使用免费证书，证书认证机构为 Let’s Encrypt。 证书的生成有许多方法，这里使用的是比较简单的方法：使用 acme.sh 脚本生成，本部分说明部分内容参考于acme.sh README。 证书有两种，一种是 ECC 证书（内置公钥是 ECDSA 公钥），一种是 RSA 证书（内置 RSA 公钥）。简单来说，同等长度 ECC 比 RSA 更安全,也就是说在具有同样安全性的情况下，ECC 的密钥长度比 RSA 短得多（加密解密会更快）。但问题是 ECC 的兼容性会差一些，Android 4.x 以下和 Windows XP 不支持。只要您的设备不是非常老的老古董，强烈建议使用 ECC 证书。 以下将给出这两类证书的生成方法，请大家根据自身的情况自行选择其中一种证书类型。 证书生成只需在服务器上操作。 1.2.1. 安装 acme.sh执行以下命令，acme.sh 会安装到 ~/.acme.sh 目录下。 1234567891011121314151617181920$ curl https://get.acme.sh | sh% Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 671 100 671 0 0 680 0 --:--:-- --:--:-- --:--:-- 679% Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 112k 100 112k 0 0 690k 0 --:--:-- --:--:-- --:--:-- 693k[Fri 30 Dec 01:03:32 GMT 2016] Installing from online archive.[Fri 30 Dec 01:03:32 GMT 2016] Downloading https://github.com/Neilpang/acme.sh/archive/master.tar.gz[Fri 30 Dec 01:03:33 GMT 2016] Extracting master.tar.gz[Fri 30 Dec 01:03:33 GMT 2016] Installing to /home/user/.acme.sh[Fri 30 Dec 01:03:33 GMT 2016] Installed to /home/user/.acme.sh/acme.sh[Fri 30 Dec 01:03:33 GMT 2016] Installing alias to '/home/user/.profile'[Fri 30 Dec 01:03:33 GMT 2016] OK, Close and reopen your terminal to start using acme.sh[Fri 30 Dec 01:03:33 GMT 2016] Installing cron jobno crontab for userno crontab for user[Fri 30 Dec 01:03:33 GMT 2016] Good, bash is found, so change the shebang to use bash as preferred.[Fri 30 Dec 01:03:33 GMT 2016] OK[Fri 30 Dec 01:03:33 GMT 2016] Install success! 安装成功后执行 source ~/.bashrc 以确保脚本所设置的命令别名生效。 如果安装报错，那么可能是因为系统缺少 acme.sh 所需要的依赖项，acme.sh 的依赖项主要是 netcat(nc)，我们通过以下命令来安装这些依赖项，然后重新安装一遍 acme.sh: 1$ sudo apt-get -y install netcat 1.2.2. 使用 acme.sh 生成证书证书生成执行以下命令生成证书： 以下的命令会临时监听 80 端口，请确保执行该命令前 80 端口没有使用 1234567891011121314151617181920212223242526272829$ sudo ~/.acme.sh/acme.sh --issue -d mydomain.me --standalone -k ec-256[Fri Dec 30 08:59:12 HKT 2016] Standalone mode.[Fri Dec 30 08:59:12 HKT 2016] Single domain='mydomain.me'[Fri Dec 30 08:59:12 HKT 2016] Getting domain auth token for each domain[Fri Dec 30 08:59:12 HKT 2016] Getting webroot for domain='mydomain.me'[Fri Dec 30 08:59:12 HKT 2016] _w='no'[Fri Dec 30 08:59:12 HKT 2016] Getting new-authz for domain='mydomain.me'[Fri Dec 30 08:59:14 HKT 2016] The new-authz request is ok.[Fri Dec 30 08:59:14 HKT 2016] mydomain.me is already verified, skip.[Fri Dec 30 08:59:14 HKT 2016] mydomain.me is already verified, skip http-01.[Fri Dec 30 08:59:14 HKT 2016] mydomain.me is already verified, skip http-01.[Fri Dec 30 08:59:14 HKT 2016] Verify finished, start to sign.[Fri Dec 30 08:59:16 HKT 2016] Cert success.-----BEGIN CERTIFICATE-----MIIEMTCCAxmgAwIBAgISA1+gJF5zwUDjNX/6Xzz5fo3lMA0GCSqGSIb3DQEBCwUAMEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQDExpMZXQncyBFbmNyeXB0IEF1dGhvcml0eSBYMzAeFw0xNjEyMjkyMzU5MDBaFw0xNzAzMjkyMzU5MDBaMBcxFTATBgNVBAMTDHdlYWtzYW5kLmNvbTBZMBMGByqGSM49****************************************************************4p40tm0aMB837XQ9jeAXvXulhVH/7/wWZ8/vkUUvuHSCYHagENiq/3DYj4a85Iw9+6u1r7atYHJ2VwqSamiyTGDQuhc5wdXIQxY/YQQqkAmn5tLsTZnnOavc4plANT40zweiG8vcIvMVnnkM0TSz8G1yzv1nOkruN3ozQkLMu6YS7lk/ENBN7DBtYVSmJeU2VAXE+zgRaP7JFOqK6DrOwhyE2LSgae83Wq/XgXxjfIo1Zmn2UmlE0sbdNKBasnf9gPUI45eltrjcv8FCSTOUcT7PWCa3-----END CERTIFICATE-----[Fri Dec 30 08:59:16 HKT 2016] Your cert is in /root/.acme.sh/mydomain.me_ecc/mydomain.me.cer[Fri Dec 30 08:59:16 HKT 2016] Your cert key is in /root/.acme.sh/mydomain.me_ecc/mydomain.me.key[Fri Dec 30 08:59:16 HKT 2016] The intermediate CA cert is in /root/.acme.sh/mydomain.me_ecc/ca.cer[Fri Dec 30 08:59:16 HKT 2016] And the full chain certs is there: /root/.acme.sh/mydomain.me_ecc/fullchain.cer -k 表示密钥长度，后面的值可以是 ec-256 、ec-284、2048、3072、4096、8192，带有 ec 表示生成的是 ECC 证书，没有则是 RSA 证书。在安全性上 256 位的 ECC 证书等同于 3072 位的 RSA 证书。 证书更新由于 Let’s Encrypt 的证书有效期只有 3 个月，因此需要 90 天至少要更新一次证书，acme.sh 脚本会每 60 天自动更新证书。也可以手动更新。 手动更新 ECC 证书，执行： 1$ sudo ~/.acme.sh/acme.sh --renew -d mydomain.com --force --ecc 如果是 RSA 证书则执行： 1$ sudo ~/.acme.sh/acme.sh --renew -d mydomain.com --force 1.2.3. 安装证书和密钥ECC 证书将证书和密钥安装到 /etc/v2ray 中： 1$ sudo ~/.acme.sh/acme.sh --installcert -d mydomain.me --fullchainpath /etc/v2ray/v2ray.crt --keypath /etc/v2ray/v2ray.key --ecc RSA 证书1$ sudo ~/.acme.sh/acme.sh --installcert -d mydomain.me --fullchainpath /etc/v2ray/v2ray.crt --keypath /etc/v2ray/v2ray.key 注意：无论什么情况，密钥(即上面的v2ray.key)都不能泄漏，如果你不幸泄漏了密钥，可以使用 acme.sh 将原证书吊销，再生成新的证书，吊销方法请自行参考 acme.sh 的手册 1.3. 配置 V2Ray1.3.1. 服务器123456789101112131415161718192021222324252627282930&#123; \"inbound\": &#123; \"port\": 443, // 建议使用 443 端口 \"protocol\": \"vmess\", \"settings\": &#123; \"clients\": [ &#123; \"id\": \"23ad6b10-8d1a-40f7-8ad0-e3e35cd38297\", \"alterId\": 64 &#125; ] &#125;, \"streamSettings\": &#123; \"network\": \"tcp\", \"security\": \"tls\", // security 要设置为 tls 才会启用 TLS \"tlsSettings\": &#123; \"certificates\": [ &#123; \"certificateFile\": \"/etc/v2ray/v2ray.crt\", //证书文件 \"keyFile\": \"/etc/v2ray/v2ray.key\" //密钥文件 &#125; ] &#125; &#125; &#125;, \"outbound\": &#123; \"protocol\": \"freedom\", \"settings\": &#123;&#125; &#125;&#125; 1.3.2. 客户端123456789101112131415161718192021222324252627282930&#123; \"inbound\": &#123; \"port\": 1080, \"protocol\": \"socks\", \"settings\": &#123; \"auth\": \"noauth\" &#125; &#125;, \"outbound\": &#123; \"protocol\": \"vmess\", \"settings\": &#123; \"vnext\": [ &#123; \"address\": \"mydomain.me\", \"port\": 443, \"users\": [ &#123; \"id\": \"23ad6b10-8d1a-40f7-8ad0-e3e35cd38297\", \"alterId\": 64 &#125; ] &#125; ] &#125;, \"streamSettings\": &#123; \"network\": \"tcp\", \"security\": \"tls\" // 客户端的 security 也要设置为 tls &#125; &#125;&#125; 1.4. 验证一般来说，按照以上步骤操作完成，V2Ray 客户端能够正常联网说明 TLS 已经成功启用。但要是有个可靠的方法来验证是否正常开启 TLS 无疑更令人放心。 验证的方法有很多，我仅介绍一种小白化一点的，便是 Qualys SSL Labs’s SSL Server Test。 注意：使用 Qualys SSL Labs’s SSL Server Test 要求使用 443 端口，意味着你服务器配置的 inbound.port 应当是 443 打开 Qualys SSL Labs’s SSL Server Test，在 Hostname 中输入你的域名，点提交，过一会结果就出来了。 这是对于你的 TLS/SSL 的一个总体评分，我这里评分为 A，看来还不错。有这样的界面算是成功了。 这是关于证书的信息。从图中可以看出，我的这个证书有效期是从 2016 年 12 月 27 号到 2017 年的 3 月 27 号，密钥是 256 位的 ECC，证书签发机构是 Let’s Encrypt，重要的是最后一行，Trusted 为 Yes,表明我这个证书可信。 1.5. 温馨提醒不要想当然地把在 SS 和 SSR 的观念带过来，更不要被别人轻飘飘的一句话误导，V2Ray 的 TLS 不是伪装！不是混淆！这是真正的 TLS！因此才需要域名需要证书。后文提到的 WS(WebSocks) 也不是伪装。","categories":[{"name":"代理技术","slug":"代理技术","permalink":"https://ycg31.oschina.io/categories/代理技术/"}],"tags":[{"name":"v2ray","slug":"v2ray","permalink":"https://ycg31.oschina.io/tags/v2ray/"}]},{"title":"Linux TCP加速工具 —— LotServer(锐速母公司) 一键安装脚本","slug":"Linux TCP加速工具 —— LotServer(锐速母公司) 一键安装脚本","date":"2017-08-19T05:20:09.000Z","updated":"2017-08-20T05:50:16.851Z","comments":true,"path":"2017/08/19/Linux TCP加速工具 —— LotServer(锐速母公司) 一键安装脚本/","link":"","permalink":"https://ycg31.oschina.io/2017/08/19/Linux TCP加速工具 —— LotServer(锐速母公司) 一键安装脚本/","excerpt":"","text":"Linux TCP加速工具 —— LotServer(锐速母公司) 一键安装脚本锐速(ServerSpeeder)可以说是LotServer的马甲，是针对民用的，而LotServer则是针对企业用户的，锐速现在基本上已经关了，而这个LotServer还在持续运营。 Only for Linux. 从根本原因上解决锐速断流问题，断流的根本原因是没有完整破解验证机制。 支持自动检测公网网卡，多个网卡也能区分。 支持自动适配内核 (需锐速支持)。 添加询问是否开启accppp功能 (实测并开启后没有效果)。 默认设置为G口宽带 (听说设置大点可以提高速度)。 支持一键完全卸载 (此脚本安装的无残留)。 所需文件均来自 GiuHub，不放心可自行查阅 (完全公开)。 不支持自动更换内核，请自行更换(网上教程非常多)。 不支持OpenVZ，不需要尝试，会告诉你找不到网卡。 1注意：OVZ虚拟化的VPS并不支持锐速加速器的安装，KVM和XEN应该基本都可以。 作者博客：https://moeclub.org/2017/03/08/14/ 安装文件 appex.zip 为 LotServer 的，(感谢 LotServer 提供安装文件)。 使用前请日常apt-get update / yum update，欢迎反馈bug(各种安装错误)。 使用前建议先查看linux支持内核列表，对照一下系统和内核是否可以安装 LotServer！ 服务器使用uname -r命令来查询内核版本，例如返回的是3.2.0-4-amd64，3.2.0-4-amd64就是你的内核版本。 强烈推荐大家使用 Debian7 x64系统 | 3.2.0-4-amd64内核 ，这个系统和内核无论是锐速、Lotserver还是BBR，除了配置太低的我都没安装失败过！ 安装LotServer1wget --no-check-certificate -qO /tmp/appex.sh \"https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh\" &amp;&amp; bash /tmp/appex.sh 'install' 安装一开始的时候，会提示： 12Press Enter to Continue...# 这个是提示你按回车键继续 如果安装过程中没问题的话，最后会提示： 12345678910Accelerate VPN (PPTP,L2TP,etc.)? [n]:# 是否加速VPN Auto load ServerSpeeder on linux start-up? [y]:# 是否开机启动 Run ServerSpeeder now? [y]:# 是否现在启动锐速 # 全部默认回车即可。 最后出现这样的提示就说明安装并启动成功： 123456789101112[Running Status]ServerSpeeder is running!version 3.11.20.4 [License Information]License 6001ADDF578B6C0E (valid on current device)MaxSession unlimitedMaxTcpAccSession unlimitedMaxBandwidth(kbps) 1024000ExpireDate 2035-12-31....# 以下省略.... 卸载LotServer1wget --no-check-certificate -qO /tmp/appex.sh \"https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh\" &amp;&amp; bash /tmp/appex.sh 'uninstall' 使用说明1234567891011121314/appex/bin/serverSpeeder.sh start# 启动 LotServer /appex/bin/serverSpeeder.sh stop# 停止 LotServer /appex/bin/serverSpeeder.sh restart# 重启 LotServer /appex/bin/serverSpeeder.sh status# 状态查询 /appex/bin/serverSpeeder.sh renewLic# 更新许可 代码托管地址 LotServer 完整使用介绍 PDF手册 安装完了，想要自己修改配置最大化加速效果，那么请看：锐速(ServerSpeeder/LotServer)配置参数简单说明，合理修改配置 提高加速效果 这个LotServer与锐速(ServerSpeeder)的加速区别并不大，不过91yun的破解版因为破解不完整导致会出现断流等情况，而这个 LotServer 则没有这种问题。","categories":[{"name":"代理技术","slug":"代理技术","permalink":"https://ycg31.oschina.io/categories/代理技术/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ycg31.oschina.io/tags/Linux/"},{"name":"速锐","slug":"速锐","permalink":"https://ycg31.oschina.io/tags/速锐/"}]}]}